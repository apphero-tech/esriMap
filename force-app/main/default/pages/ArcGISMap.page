<apex:page showHeader="false" sidebar="false" standardStylesheets="false" docType="html-5.0">
    <!-- Support Visualforce Remoting -->
    <apex:remoteObjects>
        <apex:remoteObjectModel name="ArcGIS_Tool_Settings__c" fields="Name,Tool_Type__c,Is_Enabled__c" />
    </apex:remoteObjects>
    
    <html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>ArcGIS Map</title>
        
        <!-- ArcGIS Maps SDK 4.33 -->
        <link rel="stylesheet" href="https://js.arcgis.com/4.33/esri/themes/light/main.css" />
        <script src="https://js.arcgis.com/4.33/init.js"></script>
        
        <style>
            html, body, #viewDiv {
                padding: 0;
                margin: 0;
                height: 100%;
                width: 100%;
                font-family: 'Avenir Next', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            }
            
            /* Espace entre Zoom et Locate lorsqu'ils sont en bas √† gauche */
            .esri-ui-bottom-left .esri-locate { margin-top: 8px; }
            
            /* Style pour le widget Search */
            .esri-search {
                width: 300px;
                max-width: 90vw;
            }
            
            .esri-search__input {
                border-radius: 6px;
                border: 2px solid #e1e5e9;
                font-size: 14px;
                padding: 8px 12px;
                transition: border-color 0.2s ease;
            }
            
            .esri-search__input:focus {
                border-color: #0079c1;
                outline: none;
                box-shadow: 0 0 0 3px rgba(0, 121, 193, 0.1);
            }
            
            .esri-search__suggestions {
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                border: 1px solid #e1e5e9;
            }
            
            .esri-search__suggestion {
                padding: 10px 12px;
                border-bottom: 1px solid #f0f0f0;
                cursor: pointer;
                transition: background-color 0.2s ease;
            }
            
            .esri-search__suggestion:hover {
                background-color: #f8f9fa;
            }
            
            .esri-search__suggestion:last-child {
                border-bottom: none;
            }

            /* Masquer tous les contr√¥les ArcGIS (lecture seule) sauf Zoom */
            .esri-ui-corner,
            .esri-search,
            .esri-search-*,
            .esri-compass,
            .esri-compass-*,
            .esri-locate,
            .esri-locate-*,
            .esri-basemap-toggle,
            .esri-basemap-toggle-*,
            .esri-sketch,
            .esri-sketch-*,
            .esri-ui-manual-container { display: none !important; }
        </style>
    </head>
    <body>
        <div id="viewDiv"></div>
        
        <script>
            require([
                "esri/Map",
                "esri/views/MapView",
                "esri/geometry/Point",
                "esri/Graphic",
                "esri/symbols/SimpleMarkerSymbol",
                "esri/PopupTemplate",
                "esri/widgets/Popup",
                "esri/widgets/Search",
                "esri/widgets/Compass",
                "esri/widgets/Locate",
                "esri/widgets/BasemapToggle",
                "esri/widgets/Sketch",
                "esri/layers/GraphicsLayer",
                "esri/geometry/geometryEngine",
                "esri/geometry/support/webMercatorUtils",
                "esri/core/reactiveUtils"
            ], function(Map, MapView, Point, Graphic, SimpleMarkerSymbol, PopupTemplate, Popup, Search, Compass, Locate, BasemapToggle, Sketch, GraphicsLayer, geometryEngine, webMercatorUtils, reactiveUtils) {
                
                console.log('üó∫Ô∏è Initialisation ArcGIS dans Visualforce...');
                
                // Cr√©er la carte
                const map = new Map({
                    basemap: "streets-navigation-vector"
                });

                // Cr√©er un GraphicsLayer d√©di√© pour les dessins Sketch
                const sketchLayer = new GraphicsLayer({
                    title: "Dessins utilisateur"
                });
                map.add(sketchLayer);
                
                // Layer pour les formes enregistr√©es (persistantes le temps de la session)
                const savedLayer = new GraphicsLayer({
                    title: "Formes enregistr√©es"
                });
                map.add(savedLayer);
                
                // ========================================
                // FONCTIONNALIT√âS MODE LECTURE SEULE
                // ========================================
                
                // Fonction pour afficher une g√©om√©trie en mode lecture seule
                function displayReadOnlyGeometry(data) {
                    console.log('üìç Affichage g√©om√©trie en mode lecture seule:', data);
                    
                    try {
                        // Mettre √† jour le mode global
                        window.isReadOnlyMode = data.readOnlyMode || false;
                        console.log('üîí Mode lecture seule activ√©:', window.isReadOnlyMode);
                        
                        // G√©rer l'interface en mode lecture seule
                        if (window.isReadOnlyMode) {
                            toggleReadOnlyInterface(true);
                        }
                        
                        const geometryData = data.geometry || data.geometryData;
                        const feature = typeof geometryData === 'string' ? JSON.parse(geometryData) : geometryData;
                        
                        // Effacer les graphiques existants
                        sketchLayer.removeAll();
                        
                        let graphic = null;
                        
                        // Cr√©er le graphique selon le type de g√©om√©trie
                        // Utiliser d'abord Area_Type__c du LWC, puis les propri√©t√©s GeoJSON
                        const geometryType = data.areaType || feature.properties.originalType || feature.properties.shapeType;
                        console.log('üîç Type de g√©om√©trie d√©tect√©:', geometryType);
                        
                        switch (geometryType) {
                            case 'Circle':
                                graphic = createReadOnlyCircleGraphic(feature, data.centerCoordinates);
                                break;
                            case 'Point':
                                graphic = createReadOnlyPointGraphic(feature);
                                break;
                            case 'Polygon':
                                graphic = createReadOnlyPolygonGraphic(feature);
                                break;
                            case 'Polyline':
                                graphic = createReadOnlyPolylineGraphic(feature);
                                break;
                            case 'Rectangle':
                                graphic = createReadOnlyRectangleGraphic(feature);
                                break;
                            default:
                                console.warn('‚ö†Ô∏è Type de g√©om√©trie non support√©:', geometryType);
                                console.log('üîç Donn√©es re√ßues:', data);
                                console.log('üîç Feature GeoJSON:', feature);
                        }
                        
                        // Si latitude/longitude fournies, forcer un point unique centr√©
                        if (data && typeof data.latitude === 'number' && typeof data.longitude === 'number') {
                            const pointGraphic = new Graphic({
                                geometry: new Point({ longitude: data.longitude, latitude: data.latitude }),
                                symbol: {
                                    type: "simple-marker",
                                    color: [51, 153, 255, 0.8],
                                    outline: { color: [255, 255, 255, 1], width: 2 },
                                    size: 12
                                }
                            });
                            sketchLayer.add(pointGraphic);
                            view.goTo({ target: pointGraphic.geometry, zoom: 16 }, { duration: 600 }).then(() => {
                                try {
                                    // Figer la carte (pas de pan) avec un extent autour du point
                                    if (view && view.constraints) {
                                        const lon = pointGraphic.geometry.longitude;
                                        const lat = pointGraphic.geometry.latitude;
                                        const delta = 0.0002; // env. ~20m, selon SR
                                        const extent = new Extent({ xmin: lon - delta, ymin: lat - delta, xmax: lon + delta, ymax: lat + delta, spatialReference: { wkid: 4326 } });
                                        view.constraints = {
                                            rotationEnabled: false,
                                            snapToZoom: true,
                                            geometry: extent
                                        };
                                    }
                                    if (view && view.navigation) {
                                        // D√©sactiver zoom molette et pan tactile/ clavier
                                        view.navigation.mouseWheelZoomEnabled = false;
                                        view.navigation.browserTouchPanEnabled = false;
                                        view.navigation.gamepadEnabled = false;
                                        view.navigation.keyboardEnabled = false;
                                    }
                                    view.on("drag", function(evt){ evt.stopPropagation(); });
                                    view.on("mouse-wheel", function(evt){ evt.stopPropagation(); });
                                    view.on("double-click", function(evt){ evt.stopPropagation(); });
                                    view.on("pointer-down", function(evt){ if (window.isReadOnlyMode) evt.stopPropagation(); });
                                    view.on("immediate-click", function(evt){ evt.stopPropagation(); });
                                    view.on("pointer-move", function(evt){ evt.stopPropagation(); });

                                    // Ne pas bloquer les raccourcis de zoom du navigateur pour √©viter les crashes Chrome
                                } catch (freezeErr) { console.warn('‚ö†Ô∏è Erreur lors du gel de la carte:', freezeErr); }
                            });
                            // Activer l'interface lecture seule
                            toggleReadOnlyInterface(true);
                            console.log('‚úÖ Point centr√© en lecture seule');
                            return;
                        }

                        if (graphic) {
                            // Ajouter √† la carte avec style lecture seule
                            sketchLayer.add(graphic);
                            
                            // Centrer la vue si demand√©
                            if (data && data.autoCenter) {
                                const extent = graphic.geometry.extent || graphic.geometry;
                                view.goTo({
                                    target: extent,
                                    zoom: extent.type === 'point' ? 16 : undefined
                                }).then(() => {
                                    console.log('‚úÖ Vue centr√©e sur la g√©om√©trie');
                                    try {
                                        if (view && view.constraints && graphic) {
                                            const geom = graphic.geometry;
                                            const extentGeom = geom.extent ? geom.extent : geom;
                                            view.constraints = {
                                                rotationEnabled: false,
                                                snapToZoom: true,
                                                geometry: extentGeom
                                            };
                                        }
                                        if (view && view.navigation) {
                                            view.navigation.mouseWheelZoomEnabled = false;
                                            view.navigation.browserTouchPanEnabled = false;
                                            view.navigation.gamepadEnabled = false;
                                            view.navigation.keyboardEnabled = false;
                                        }
                                        view.on("drag", function(evt){ evt.stopPropagation(); });
                                        view.on("mouse-wheel", function(evt){ evt.stopPropagation(); });
                                        view.on("double-click", function(evt){ evt.stopPropagation(); });
                                        view.on("pointer-down", function(evt){ if (window.isReadOnlyMode) evt.stopPropagation(); });
                                        view.on("immediate-click", function(evt){ evt.stopPropagation(); });
                                        view.on("pointer-move", function(evt){ evt.stopPropagation(); });

                                        // Ne pas installer de hook clavier global pour √©viter les crashes
                                    } catch (freezeErr) { console.warn('‚ö†Ô∏è Erreur lors du gel de la carte:', freezeErr); }
                                });
                            }
                            
                            // D√©sactiver les outils de dessin en mode lecture seule
                            if (window.sketchWidget) {
                                window.sketchWidget.cancel();
                                window.sketchWidget.view = null; // D√©sactiver compl√®tement
                            }
                            
                            console.log('‚úÖ G√©om√©trie affich√©e en mode lecture seule');
                        }
                        
                    } catch (error) {
                        console.error('‚ùå Erreur affichage g√©om√©trie lecture seule:', error);
                    }
                }
                
                // Fonction pour cr√©er un cercle en lecture seule
                function createReadOnlyCircleGraphic(feature, centerCoordinates) {
                    const radius = feature.properties.radius;
                    let center;
                    
                    // Utiliser les coordonn√©es du centre si disponibles
                    if (centerCoordinates && centerCoordinates.latitude && centerCoordinates.longitude) {
                        center = [centerCoordinates.longitude, centerCoordinates.latitude];
                    } else if (feature.geometry.coordinates && feature.geometry.coordinates[0] && feature.geometry.coordinates[1]) {
                        center = feature.geometry.coordinates;
                    } else {
                        console.warn('‚ö†Ô∏è Coordonn√©es du centre manquantes pour le cercle');
                        return null;
                    }
                    
                    // Cr√©er le cercle
                    const circle = new geometryEngine.geodesicBuffer(
                        new Point({
                            longitude: center[0],
                            latitude: center[1]
                        }),
                        radius,
                        'meters'
                    );
                    
                    return new Graphic({
                        geometry: circle,
                        symbol: {
                            type: "simple-fill",
                            color: [51, 153, 255, 0.3], // Bleu clair transparent
                            outline: {
                                color: [51, 153, 255, 0.8], // Bleu plus fonc√©
                                width: 2
                            }
                        }
                    });
                }
                
                // Fonction pour cr√©er un point en lecture seule
                function createReadOnlyPointGraphic(feature) {
                    const coords = feature.geometry.coordinates;
                    
                    return new Graphic({
                        geometry: new Point({
                            longitude: coords[0],
                            latitude: coords[1]
                        }),
                        symbol: {
                            type: "simple-marker",
                            color: [51, 153, 255, 0.8],
                            outline: {
                                color: [51, 153, 255, 1],
                                width: 2
                            },
                            size: 12
                        }
                    });
                }
                
                // Fonction pour cr√©er un polygone en lecture seule
                function createReadOnlyPolygonGraphic(feature) {
                    return new Graphic({
                        geometry: {
                            type: "polygon",
                            rings: feature.geometry.coordinates
                        },
                        symbol: {
                            type: "simple-fill",
                            color: [51, 153, 255, 0.3],
                            outline: {
                                color: [51, 153, 255, 0.8],
                                width: 2
                            }
                        }
                    });
                }
                
                // Fonction pour cr√©er une polyligne en lecture seule
                function createReadOnlyPolylineGraphic(feature) {
                    return new Graphic({
                        geometry: {
                            type: "polyline",
                            paths: feature.geometry.coordinates
                        },
                        symbol: {
                            type: "simple-line",
                            color: [51, 153, 255, 0.8],
                            width: 3
                        }
                    });
                }
                
                // Fonction pour cr√©er un rectangle en lecture seule
                function createReadOnlyRectangleGraphic(feature) {
                    // Les rectangles sont stock√©s comme des polygones
                    return createReadOnlyPolygonGraphic(feature);
                }
                
                // Fonction pour g√©rer l'interface en mode lecture seule
                function toggleReadOnlyInterface(isReadOnly) {
                    console.log('üîí Gestion interface mode lecture seule:', isReadOnly);
                    
                    if (isReadOnly) {
                        // Mode lecture seule : supprimer les composants UI et widgets
                        console.log('üîí Suppression des widgets en mode lecture seule');
                        try { if (typeof view !== 'undefined' && view && view.ui) { view.ui.components = ["zoom"]; } } catch (e) {}
                        // Retirer explicitement les widgets ajout√©s √† l'UI (on garde uniquement Zoom via components)
                        try { if (searchWidget) { view.ui.remove(searchWidget); } } catch (e) {}
                        try { if (compassWidget) { view.ui.remove(compassWidget); } } catch (e) {}
                        try { if (locateWidget) { view.ui.remove(locateWidget); } } catch (e) {}
                        try { if (basemapToggleWidget) { view.ui.remove(basemapToggleWidget); } } catch (e) {}
                        try { if (window.sketchWidget) { view.ui.remove(window.sketchWidget); } } catch (e) {}
                        
                        // Masquer le widget Search
                        if (searchWidget && searchWidget.container) {
                            searchWidget.container.style.display = 'none';
                        }
                        
                        // Masquer le widget Compass
                        if (compassWidget && compassWidget.container) {
                            compassWidget.container.style.display = 'none';
                        }
                        
                        // Masquer le widget Locate
                        if (locateWidget && locateWidget.container) {
                            locateWidget.container.style.display = 'none';
                        }
                        
                        // Masquer le widget BasemapToggle
                        if (basemapToggleWidget && basemapToggleWidget.container) {
                            basemapToggleWidget.container.style.display = 'none';
                        }
                        
                        // Masquer le widget Sketch
                        if (window.sketchWidget && window.sketchWidget.container) {
                            window.sketchWidget.container.style.display = 'none';
                        }
                        
                        console.log('‚úÖ Widgets masqu√©s en mode lecture seule');
                        
                    } else {
                        // Mode √©dition : afficher tous les widgets
                        console.log('‚úèÔ∏è Affichage des widgets en mode √©dition');
                        
                        // Afficher le widget Search
                        if (searchWidget && searchWidget.container) {
                            searchWidget.container.style.display = 'block';
                        }
                        
                        // Afficher le widget Compass
                        if (compassWidget && compassWidget.container) {
                            compassWidget.container.style.display = 'block';
                        }
                        
                        // Afficher le widget Locate
                        if (locateWidget && locateWidget.container) {
                            locateWidget.container.style.display = 'block';
                        }
                        
                        // Afficher le widget BasemapToggle
                        if (basemapToggleWidget && basemapToggleWidget.container) {
                            basemapToggleWidget.container.style.display = 'block';
                        }
                        
                        // Afficher le widget Sketch
                        if (window.sketchWidget && window.sketchWidget.container) {
                            window.sketchWidget.container.style.display = 'block';
                        }
                        
                        console.log('‚úÖ Widgets affich√©s en mode √©dition');
                    }
                }
                
                // Cr√©er la vue
                const view = new MapView({
                    container: "viewDiv",
                    map: map,
                    center: [-73.5673, 45.5017], // Place Ville-Marie, Montr√©al
                    zoom: 15,
                    constraints: {
                        rotationEnabled: true, // Activer la rotation pour le Compass
                        rotationAngle: 0 // Commencer avec l'orientation nord
                    }
                });
                
                // ========================================
                // √âCOUTEUR DE MESSAGES POUR MODE LECTURE SEULE
                // ========================================
                
                // √âcouter les messages du composant LWC pour le mode lecture seule
                window.addEventListener('message', function(event) {
                    if (event.data && event.data.type === 'DISPLAY_READONLY_GEOMETRY') {
                        console.log('üì® Message re√ßu du LWC:', event.data);
                        var payload = (event.data && event.data.data) ? event.data.data : event.data;
                        try { window.isReadOnlyMode = !!(payload && payload.readOnlyMode); } catch (e) {}
                        displayReadOnlyGeometry(payload);
                    }
                });

                // Cr√©er et configurer le widget Search avec autocompl√©tion (sans g√©olocalisation)
                const searchWidget = new Search({
                    view: view,
                    sources: [{
                        url: "https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer",
                        singleLineFieldName: "SingleLine",
                        name: "ArcGIS World Geocoding Service",
                        countryCode: "CAN", // Priorit√© au Canada
                        maxResults: 10,
                        maxSuggestions: 8,
                        minSuggestCharacters: 1,
                        searchExtent: view.extent
                    }],
                    autoComplete: true,
                    searchAllEnabled: false, // D√©sactiver la recherche globale pour √©viter la g√©olocalisation
                    includeDefaultSources: false, // Exclure les sources par d√©faut (incluant g√©olocalisation)
                    locationEnabled: false, // D√©sactiver explicitement la g√©olocalisation dans Search
                    popupEnabled: false, // On g√®re nos propres popups
                    resultGraphicEnabled: false, // On g√®re nos propres graphics
                    container: "searchContainer"
                });
                
                // Variable globale pour le mode lecture seule
                window.isReadOnlyMode = false;

                // Cr√©er et configurer le widget Compass (navigation)
                const compassWidget = new Compass({
                    view: view,
                    label: "R√©initialiser l'orientation nord"
                });

                // √âcouter les changements de rotation pour informer l'utilisateur
                reactiveUtils.watch(() => view.rotation, function(rotation) {
                    if (Math.abs(rotation) > 1) { // Si rotation significative
                        console.log('üß≠ Carte tourn√©e de', rotation.toFixed(1), 'degr√©s');
                        console.log('üí° Cliquez sur le compass pour remettre au nord');
                    }
                });

                // √âcouter les clics sur le compass
                compassWidget.on("click", function() {
                    console.log('üß≠ Compass cliqu√© - orientation remise au nord');
                });

                // Cr√©er et configurer le widget Locate (g√©olocalisation native ArcGIS)
                const locateWidget = new Locate({
                    view: view,
                    label: "Ma position",
                    useHeadingEnabled: true,
                    goToOverride: function(view, options) {
                        // Personnaliser le comportement de navigation vers la position
                        view.goTo({
                            target: options.target,
                            zoom: 18, // Zoom plus proche pour la position utilisateur
                            duration: 1000
                        });
                    }
                });

                // Cr√©er et configurer le widget BasemapToggle (changement de fond de carte)
                const basemapToggleWidget = new BasemapToggle({
                    view: view,
                    nextBasemap: "satellite", // Vue satellite comme alternative
                    label: "Basculer vers satellite"
                });

                // NOUVELLE APPROCHE: Cr√©er le widget Sketch SANS l'attacher √† la vue
                // Cela pr√©serve le comportement natif ArcGIS par d√©faut
                console.log('üéØ Mode NATIF ArcGIS activ√© - g√©ocodage sur clic disponible');
                
                // Variable globale pour le widget (cr√©√© mais pas attach√©)
                window.sketchWidget = null;
                window.sketchConfig = null;
                
                // Charger la configuration et cr√©er le widget Sketch automatiquement
                loadDrawingToolsConfig().then(config => {
                    console.log('üîß Configuration des outils charg√©e:', config);
                    
                    // Stocker la configuration pour utilisation ult√©rieure
                    window.sketchConfig = config;
                    console.log('üìã Configuration stock√©e - cr√©ation automatique du widget Sketch');
                    
                    // En lecture seule, ne pas cr√©er/ajouter le widget Sketch
                    if (!window.isReadOnlyMode) {
                        // CR√âER AUTOMATIQUEMENT LE WIDGET SKETCH AVEC LA CONFIGURATION
                        createAndActivateSketchWidget();
                    } else {
                        console.log('üîí Lecture seule active - widget Sketch non cr√©√©');
                    }
                    
                }).catch(error => {
                    console.error('‚ùå Erreur lors du chargement de la configuration:', error);
                    
                    // Configuration par d√©faut en cas d'erreur
                    window.sketchConfig = {
                        pointTool: true,
                        polylineTool: true,
                        polygonTool: true,
                        rectangleTool: true,
                        circleTool: true,
                        lassoSelection: false,
                        rectangleSelection: false
                    };
                    console.log('üìã Configuration par d√©faut stock√©e');
                });

                // Fonction pour charger la configuration des outils depuis Custom Settings List
                function loadDrawingToolsConfig() {
                    return new Promise((resolve, reject) => {
                        try {
                            console.log('üîß Chargement de la configuration depuis Custom Settings List via Remote Objects...');
                            
                            // Utiliser Remote Objects pour r√©cup√©rer la configuration
                            const toolSettings = new SObjectModel.ArcGIS_Tool_Settings__c();
                            
                            toolSettings.retrieve({}, function(error, records) {
                                if (error) {
                                    console.error('‚ùå Erreur lors de la r√©cup√©ration des Custom Settings:', error);
                                    
                                    // Configuration par d√©faut en cas d'erreur
                                    const defaultConfig = {
                                        pointTool: false,
                                        polylineTool: false,
                                        polygonTool: false,
                                        rectangleTool: true,        // D√âFAUT: activ√©
                                        circleTool: true,           // D√âFAUT: activ√©
                                        lassoSelection: false,
                                        rectangleSelection: false
                                    };
                                    
                                    console.log('‚ö†Ô∏è Utilisation de la configuration par d√©faut:', defaultConfig);
                                    resolve(defaultConfig);
                                } else {
                                    console.log('‚úÖ Custom Settings r√©cup√©r√©s:', records);
                                    
                                    // Mapper les enregistrements vers la configuration
                                    const config = {
                                        pointTool: false,
                                        polylineTool: false,
                                        polygonTool: false,
                                        rectangleTool: false,
                                        circleTool: false,
                                        lassoSelection: false,
                                        rectangleSelection: false
                                    };
                                    
                                    records.forEach(record => {
                                        const toolType = record.get('Tool_Type__c');
                                        const isEnabled = record.get('Is_Enabled__c');
                                        
                                        console.log(`üîß Outil: ${record.get('Name')} (${toolType}) = ${isEnabled}`);
                                        
                                        switch(toolType) {
                                            case 'point':
                                                config.pointTool = isEnabled;
                                                break;
                                            case 'polyline':
                                                config.polylineTool = isEnabled;
                                                break;
                                            case 'polygon':
                                                config.polygonTool = isEnabled;
                                                break;
                                            case 'rectangle':
                                                config.rectangleTool = isEnabled;
                                                break;
                                            case 'circle':
                                                config.circleTool = isEnabled;
                                                break;
                                            case 'lasso-selection':
                                                config.lassoSelection = isEnabled;
                                                break;
                                            case 'rectangle-selection':
                                                config.rectangleSelection = isEnabled;
                                                break;
                                        }
                                    });
                                    
                                    console.log('üé® Configuration finale:', config);
                                    resolve(config);
                                }
                            });
                            
                        } catch (error) {
                            console.error('‚ùå Erreur lors du chargement de la configuration:', error);
                            
                            // Configuration par d√©faut en cas d'erreur
                            resolve({
                                pointTool: false,
                                polylineTool: false,
                                polygonTool: false,
                                rectangleTool: true,        // D√âFAUT: activ√©
                                circleTool: true,           // D√âFAUT: activ√©
                                lassoSelection: false,
                                rectangleSelection: false
                            });
                        }
                    });
                }
                

                
                // Fonction pour cr√©er et activer le widget Sketch √† la demande
                function createAndActivateSketchWidget() {
                    console.log('üé® Cr√©ation du widget Sketch avec configuration Custom Settings...');
                    
                    if (window.sketchWidget) {
                        console.log('‚ö†Ô∏è Widget Sketch d√©j√† cr√©√©');
                        return window.sketchWidget;
                    }
                    
                    if (!window.sketchConfig) {
                        console.error('‚ùå Configuration non disponible');
                        return null;
                    }
                    
                    console.log('üîß Configuration appliqu√©e au widget Sketch:', window.sketchConfig);
                    
                    // Cr√©er le widget avec la configuration stock√©e
                const sketchWidget = new Sketch({
                    view: view,
                    layer: sketchLayer,
                        creationMode: "hybrid",
                        defaultUpdateOptions: { 
                            enableRotation: false,
                            enableScaling: false,
                            preserveAspectRatio: true
                        },
                    label: "Outils de dessin ArcGIS",
                    visibleElements: {
                        createTools: {
                                point: window.sketchConfig.pointTool,
                                polyline: window.sketchConfig.polylineTool,
                                polygon: window.sketchConfig.polygonTool,
                                rectangle: window.sketchConfig.rectangleTool,
                                circle: window.sketchConfig.circleTool
                        },
                        selectionTools: {
                                "lasso-selection": window.sketchConfig.lassoSelection,
                                "rectangle-selection": window.sketchConfig.rectangleSelection
                        },
                        undoRedoMenu: true,
                        settingsMenu: true
                    }
                });

                    // Stocker globalement
                    window.sketchWidget = sketchWidget;
                    
                    // Suivre l'√©tat d'activation d'un outil de cr√©ation
                    window.isSketchCreateMode = false;
                    reactiveUtils.watch(() => sketchWidget.activeTool, function(newTool){
                        window.isSketchCreateMode = !!newTool;
                        console.log('üõ†Ô∏è activeTool chang√©:', newTool, 'createMode =', window.isSketchCreateMode);
                        if (view && view.popup) {
                            if (window.isSketchCreateMode) {
                                // Fermer et d√©sactiver l'auto-ouverture du popup pour ne pas g√™ner le dessin
                                if (typeof view.popup.close === 'function') {
                                    view.popup.close();
                                } else {
                                    view.popup.visible = false;
                                }
                                view.popup.autoOpenEnabled = false;
                            } else {
                                view.popup.autoOpenEnabled = true;
                            }
                        }
                    });
                    
                    // AJOUTER LE WIDGET √Ä LA VUE (c'est ce qui manquait !)
                    view.ui.add(sketchWidget, "bottom-right");
                    console.log('üìç Widget Sketch ajout√© √† la vue en bas √† droite');
                    
                    // Initialiser le widget
                    initializeSketchWidget(sketchWidget);
                    
                    console.log('‚úÖ Widget Sketch cr√©√©, ajout√© √† la vue et activ√©');
                    return sketchWidget;
                }
                
                // Fonction pour d√©sactiver et d√©truire le widget Sketch
                function deactivateSketchWidget() {
                    console.log('üóëÔ∏è D√©sactivation du widget Sketch...');
                    
                    if (window.sketchWidget) {
                        // Annuler toute op√©ration en cours
                        window.sketchWidget.cancel();
                        
                        // D√©truire le widget
                        window.sketchWidget.destroy();
                        window.sketchWidget = null;
                        
                        console.log('‚úÖ Widget Sketch d√©sactiv√© - mode natif ArcGIS restaur√©');
                    }
                }
                
                // Fonction pour initialiser le widget Sketch (appel√©e apr√®s cr√©ation)
                function initializeSketchWidget(sketchWidget) {
                // Attendre que le widget soit initialis√©
                sketchWidget.when(() => {
                    console.log('‚úÖ Widget Sketch initialis√© avec succ√®s');
                        console.log('üé® Outils configur√©s selon Custom Settings');
                        
                        // √âTAT INITIAL: FORC√â EN MODE INACTIF POUR G√âOCODAGE
                        // Annuler tous les outils actifs et d√©sactiver le widget par d√©faut
                        sketchWidget.cancel(); // Annule tout outil de cr√©ation actif
                        // sketchWidget.viewModel.state = "ready"; // Force l'√©tat ready (retir√© car non assignable)
                        
                        console.log('üñ±Ô∏è Widget Sketch en mode READY - g√©ocodage disponible');
                        console.log('üîß √âtat du widget:', sketchWidget.viewModel.state);
                        
                        // Configurer les styles de highlight
                        setupHighlightStyles();
                    
                    // √âcouter la cr√©ation de formes
                    sketchWidget.on("create", function(event) {
                        console.log('üé® Forme cr√©√©e:', event);
                        if (event.state === "complete") {
                            handleShapeCreated(event.graphic, event.tool);
                        }
                    });
                    
                    // √âcouter la s√©lection de formes
                    sketchWidget.on("select", function(event) {
                        console.log('üéØ Forme s√©lectionn√©e:', event);
                        if (event.graphics && event.graphics.length > 0) {
                            console.log('‚úÖ Forme s√©lectionn√©e, envoi SHAPE_SELECTED');
                            handleShapeCreated(event.graphics[0]);
                        }
                    });
                    
                    // √âcouter la d√©s√©lection de formes
                    sketchWidget.on("update", function(event) {
                        console.log('üîÑ Forme mise √† jour:', event);
                        if (event.state === "complete" && event.graphics && event.graphics.length > 0) {
                            console.log('‚úÖ Forme mise √† jour, envoi SHAPE_SELECTED');
                            handleShapeCreated(event.graphics[0], undefined);
                        }
                    });
                    
                    // √âcouter la suppression de formes
                    sketchWidget.on("delete", function(event) {
                        console.log('üóëÔ∏è Forme supprim√©e:', event);
                        handleShapeDeletion();
                    });
                    
                    // √âcouter les changements d'√©tat pour activer le bouton Save
                    sketchWidget.viewModel.on("create", function(event) {
                        console.log('üé® Cr√©ation en cours:', event);
                        if (event.state === "complete") {
                            console.log('‚úÖ Cr√©ation termin√©e, envoi SHAPE_SELECTED');
                            handleShapeCreated(event.graphic);
                        }
                    });
                        
                        // IMPORTANT: Pr√©server le g√©ocodage sur clic de carte
                        // √âcouter les changements d'outil pour maintenir le g√©ocodage actif
                        reactiveUtils.watch(() => sketchWidget.viewModel.state, function(newState) {
                            console.log('üîß √âtat du widget Sketch chang√©:', newState);
                            
                            // Si aucun outil de cr√©ation n'est actif, le g√©ocodage reste disponible
                            if (newState === "ready" || newState === "disabled") {
                                console.log('üñ±Ô∏è Curseur de navigation/g√©ocodage disponible');
                                // La carte peut recevoir les clics pour le g√©ocodage
                            }
                    });
                });
                    
                    // Rendre le sketchWidget disponible globalement pour les autres fonctions
                    window.sketchWidget = sketchWidget;
                    
                    // V√©rifier s'il y a des formes existantes pour activer le bouton Save
                    setTimeout(() => {
                        activateSaveButtonIfShapesExist();
                    }, 1000);
                }
                
                // Fonction pour g√©rer la cr√©ation d'une forme
                function handleShapeCreated(graphic, tool) {
                    console.log('üé® Nouvelle forme cr√©√©e:', graphic);
                    
                    // Notifier le LWC qu'une forme est disponible
                    if (window.parent) {
                        window.parent.postMessage({
                            type: 'SHAPE_SELECTED',
                            shape: extractShapeInfo(graphic, tool)
                        }, '*');
                    }
                    
                    // Activer le bouton Save si des formes sont pr√©sentes
                    activateSaveButtonIfShapesExist();
                }
                
                // Fonction pour g√©rer la s√©lection de formes
                function handleShapeSelection() {
                    const selectedGraphics = sketchWidget.view.graphics.filter(g => g.selected);
                    console.log('üéØ Formes s√©lectionn√©es:', selectedGraphics.length);
                    
                    if (selectedGraphics.length > 0) {
                        // Notifier le LWC qu'une forme est s√©lectionn√©e
                        if (window.parent) {
                            window.parent.postMessage({
                                type: 'SHAPE_SELECTED',
                                shape: extractShapeInfo(selectedGraphics[0])
                            }, '*');
                        }
                    } else {
                        // Notifier le LWC qu'aucune forme n'est s√©lectionn√©e
                        if (window.parent) {
                            window.parent.postMessage({
                                type: 'NO_SHAPE_SELECTED'
                            }, '*');
                        }
                    }
                }
                
                // Fonction pour g√©rer la suppression de formes
                function handleShapeDeletion() {
                    const remainingGraphics = sketchWidget.view.graphics.length;
                    console.log('üóëÔ∏è Formes restantes:', remainingGraphics);
                    
                    if (remainingGraphics === 0) {
                        // Notifier le LWC qu'aucune forme n'est disponible
                        if (window.parent) {
                            window.parent.postMessage({
                                type: 'NO_SHAPE_SELECTED'
                            }, '*');
                        }
                    } else {
                        // Activer le bouton Save si des formes restent
                        activateSaveButtonIfShapesExist();
                    }
                }
                
                // Fonction pour activer le bouton Save si des formes existent
                function activateSaveButtonIfShapesExist() {
                    if (sketchWidget && sketchWidget.view) {
                        const graphics = sketchWidget.view.graphics.filter(g => g.geometry);
                        if (graphics.length > 0) {
                            console.log('‚úÖ Formes pr√©sentes sur la carte, activation du bouton Save');
                            if (window.parent) {
                                window.parent.postMessage({
                                    type: 'SHAPE_SELECTED',
                                    shape: extractShapeInfo(graphics[0])
                                }, '*');
                            }
                        }
                    }
                }
                

                
                // Fonction pour extraire les informations d'une forme
                function extractShapeInfo(graphic, tool) {
                    if (!graphic) {
                        console.error('‚ùå Graphic est null ou undefined');
                        throw new Error('Graphic invalide');
                    }
                    
                    if (!graphic.geometry) {
                        console.error('‚ùå Geometry est null ou undefined dans le graphic:', graphic);
                        throw new Error('G√©om√©trie invalide');
                    }
                    
                    const geometry = graphic.geometry;
                    console.log('üîç G√©om√©trie √† extraire:', geometry);
                    
                    let shapeInfo = {
                        type: 'unknown',
                        coordinates: [],
                        center: null,
                        isCircle: false, // Flag pour pr√©server le type m√©tier Circle
                        address: null // Adresse obtenue par g√©ocodage
                    };
                    
                    // R√©cup√©rer l'adresse si disponible
                    if (graphic.attributes && graphic.attributes.address) {
                        const address = graphic.attributes.address;
                        if (address && address !== "G√©ocodage en cours..." && 
                            address !== "Adresse non trouv√©e" && 
                            address !== "Erreur de g√©ocodage") {
                            shapeInfo.address = address;
                        }
                    }
                    
                    // Convertir la g√©om√©trie en WGS84 si n√©cessaire
                    const wgs84Geometry = convertToWGS84(geometry);
                    
                    if (wgs84Geometry.type === 'point') {
                        shapeInfo.type = 'Point';
                        shapeInfo.coordinates = [{
                            latitude: wgs84Geometry.latitude,
                            longitude: wgs84Geometry.longitude
                        }];
                        shapeInfo.center = {
                            latitude: wgs84Geometry.latitude,
                            longitude: wgs84Geometry.longitude
                        };
                    } else if (wgs84Geometry.type === 'polyline') {
                        shapeInfo.type = 'Polyline';
                        shapeInfo.coordinates = wgs84Geometry.paths[0].map(coord => ({
                            latitude: coord[1],
                            longitude: coord[0]
                        }));
                        shapeInfo.center = wgs84Geometry.extent.center;
                    } else if (wgs84Geometry.type === 'polygon') {
                        // V√©rifier si c'est un cercle (cr√©√© avec l'outil circle)
                        const isCircle = isPolygonACircle(wgs84Geometry);
                        shapeInfo.type = isCircle ? 'Circle' : 'Polygon';
                        shapeInfo.isCircle = isCircle;
                        
                        shapeInfo.coordinates = wgs84Geometry.rings[0].map(coord => ({
                            latitude: coord[1],
                            longitude: coord[0]
                        }));
                        shapeInfo.center = wgs84Geometry.extent.center;
                    } else if (wgs84Geometry.type === 'extent') {
                        // Rectangle ou cercle
                        if (wgs84Geometry.width === wgs84Geometry.height) {
                            shapeInfo.type = 'Circle';
                            shapeInfo.isCircle = true;
                        } else {
                            shapeInfo.type = 'Rectangle';
                        }
                        const xmin = wgs84Geometry.xmin;
                        const ymin = wgs84Geometry.ymin;
                        const xmax = wgs84Geometry.xmax;
                        const ymax = wgs84Geometry.ymax;
                        shapeInfo.coordinates = [
                            { latitude: ymin, longitude: xmin },
                            { latitude: ymin, longitude: xmax },
                            { latitude: ymax, longitude: xmax },
                            { latitude: ymax, longitude: xmin },
                            { latitude: ymin, longitude: xmin }
                        ];
                        shapeInfo.center = wgs84Geometry.center;
                    }
                    
                    // Si l'outil est connu, forcer le type attendu plateforme
                    if (tool) {
                        const toolMap = { point: 'Point', polyline: 'Polyline', polygon: 'Polygon', rectangle: 'Rectangle', circle: 'Circle' };
                        const mapped = toolMap[tool];
                        if (mapped) {
                            shapeInfo.type = mapped;
                            if (mapped === 'Circle') {
                                shapeInfo.isCircle = true;
                            }
                        }
                    }
                    
                    return shapeInfo;
                }
                
                // Fonction pour convertir une g√©om√©trie en WGS84
                function convertToWGS84(geometry) {
                    // V√©rifier si la g√©om√©trie est d√©j√† en WGS84
                    if (geometry.spatialReference && geometry.spatialReference.wkid === 4326) {
                        return geometry;
                    }
                    
                    try {
                        // G√©rer le cas WebMercator standard (102100/3857)
                        const wkid = geometry.spatialReference && geometry.spatialReference.wkid;
                        if (wkid === 102100 || wkid === 3857) {
                            const converted = webMercatorUtils.webMercatorToGeographic(geometry);
                            if (converted) {
                                return converted;
                            }
                        }
                        
                        // Si non convertible, retourner tel quel
                        console.warn('‚ö†Ô∏è Conversion WGS84 non appliqu√©e, WKID:', wkid);
                        return geometry;
                    } catch (e) {
                        console.error('‚ùå Erreur conversion WGS84:', e);
                        return geometry; // Fallback sans conversion
                    }
                }
                
                // Fonction pour d√©tecter si un polygone est un cercle
                function isPolygonACircle(geometry) {
                    if (geometry.type !== 'polygon' || !geometry.rings || geometry.rings.length === 0) {
                        return false;
                    }
                    
                    const ring = geometry.rings[0];
                    if (ring.length < 4) return false;
                    
                    // V√©rifier si c'est approximativement circulaire
                    // Un cercle a des angles r√©guliers et une forme relativement sym√©trique
                    const center = geometry.extent.center;
                    const distances = ring.map(coord => {
                        const dx = coord[0] - center.longitude;
                        const dy = coord[1] - center.latitude;
                        return Math.sqrt(dx * dx + dy * dy);
                    });
                    
                    // Calculer la variance des distances (plus elle est faible, plus c'est circulaire)
                    const avgDistance = distances.reduce((sum, d) => sum + d, 0) / distances.length;
                    const variance = distances.reduce((sum, d) => sum + Math.pow(d - avgDistance, 2), 0) / distances.length;
                    const coefficientOfVariation = Math.sqrt(variance) / avgDistance;
                    
                    // Si le coefficient de variation est faible, c'est probablement un cercle
                    return coefficientOfVariation < 0.1; // Seuil ajustable
                }
                
                // Fonction pour s'assurer que les coordonn√©es sont en WGS84
                function ensureWGS84Coordinates(shapeInfo) {
                    // V√©rifier si les coordonn√©es sont dans les bornes WGS84
                    const isValidWGS84 = (lat, lon) => lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180;
                    
                    // V√©rifier le centre
                    if (shapeInfo.center && !isValidWGS84(shapeInfo.center.latitude, shapeInfo.center.longitude)) {
                        console.warn('‚ö†Ô∏è Coordonn√©es du centre hors bornes WGS84:', shapeInfo.center);
                    }
                    
                    // V√©rifier toutes les coordonn√©es
                    if (shapeInfo.coordinates) {
                        shapeInfo.coordinates.forEach((coord, index) => {
                            if (!isValidWGS84(coord.latitude, coord.longitude)) {
                                console.warn(`‚ö†Ô∏è Coordonn√©e ${index} hors bornes WGS84:`, coord);
                            }
                        });
                    }
                    
                    return shapeInfo;
                }

                // Gestion simple des erreurs de g√©olocalisation
                locateWidget.on("locate-error", function(event) {
                    console.warn('‚ö†Ô∏è Erreur de g√©olocalisation:', event.error);
                    
                    if (event.error.code === 1) {
                        // Permission refus√©e
                        console.warn('‚ùå Permission de g√©olocalisation refus√©e par l\'utilisateur');
                    } else if (event.error.code === 2) {
                        // Position indisponible
                        console.warn('‚ùå Position indisponible');
                    } else if (event.error.code === 3) {
                        // Timeout
                        console.warn('‚è∞ Timeout de g√©olocalisation');
                    }
                });

                // G√©rer le succ√®s de g√©olocalisation
                locateWidget.on("locate", function(event) {
                    console.log('‚úÖ G√©olocalisation r√©ussie:', event);
                });

                // Ajouter les widgets SEULEMENT si mode √©dition (pas lecture seule)
                if (!window.isReadOnlyMode) {
                    // Ajouter le widget Locate √† la vue
                    view.ui.add(locateWidget, "bottom-left");

                    // Ajouter les widgets √† la vue selon les conventions ArcGIS
                    // Search reste en haut √† gauche
                    view.ui.add(searchWidget, { position: "top-left", index: 0 });
                    // D√©placer Zoom et Locate en bas √† gauche (Zoom au-dessus)
                    try { view.ui.move("zoom", { position: "bottom-left", index: 0 }); } catch (e) { try { view.ui.move("zoom", "bottom-left"); } catch (ignore) {} }
                    view.ui.add(locateWidget, { position: "bottom-left", index: 1 });
                    view.ui.add(compassWidget, "top-right");   // Compass (navigation)
                    view.ui.add(basemapToggleWidget, "top-right"); // BasemapToggle (changement de fond)
                    view.ui.add(sketchWidget, "bottom-right"); // Sketch (outils de dessin)
                } else {
                    // En lecture seule, s'assurer que le contr√¥leur Zoom est visible en bas √† droite
                    try { view.ui.move("zoom", "bottom-right"); } catch (e) {}
                }
                // Zoom reste en "bottom-right" par d√©faut (coexiste avec Sketch)

                console.log('üéØ Widgets ajout√©s selon conventions ArcGIS:');
                console.log('  - Search: top-left (recherche)');
                console.log('  - Compass: top-right (navigation)');
                console.log('  - BasemapToggle: top-right (changement de fond)');
                console.log('  - Locate: bottom-left (g√©olocalisation)');
                console.log('  - Sketch: bottom-right (outils de dessin)');
                console.log('  - Zoom: bottom-right (par d√©faut, coexiste avec Sketch)');
                console.log('');
                console.log('üß≠ ROTATION ACTIV√âE:');
                console.log('  - PC: Shift + glisser pour tourner la carte');
                console.log('  - Mobile: Rotation avec deux doigts');
                console.log('  - Compass: Clic pour remettre au nord');

                // √âcouter la s√©lection d'une suggestion de recherche
                searchWidget.on("select-result", function(event) {
                    console.log('üîç Suggestion s√©lectionn√©e:', event);
                    
                    if (event.result) {
                        const result = event.result;
                        const location = result.extent || result.feature.geometry;
                        
                        if (location) {
                            // Centrer la carte sur le r√©sultat
                            if (location.extent) {
                                view.goTo(location.extent, { duration: 1000 });
                            } else {
                                view.goTo(location, { duration: 1000 });
                            }
                            
                            // Cr√©er un marqueur sur l'emplacement trouv√©
                            const point = location.extent ? location.extent.center : location;
                            const symbol = new SimpleMarkerSymbol({
                                color: [0, 122, 194], // Bleu ArcGIS
                                outline: {
                                    color: [255, 255, 255],
                                    width: 2
                                },
                                size: 12
                            });
                            
                            const graphic = new Graphic({
                                geometry: point,
                                symbol: symbol,
                                attributes: {
                                    latitude: point.latitude ? point.latitude.toFixed(6) : "N/A",
                                    longitude: point.longitude ? point.longitude.toFixed(6) : "N/A",
                                    address: result.name || "Adresse trouv√©e"
                                },
                                popupTemplate: popupTemplate
                            });
                            
                            // Nettoyer les anciens marqueurs et ajouter le nouveau
                            view.graphics.removeAll();
                            view.graphics.add(graphic);
                            
                            // Ouvrir imm√©diatement le popup avec "G√©ocodage en cours..."
                            view.openPopup({
                                title: "üìç Adresse",
                                content: `
                                    <div style="padding: 15px; text-align: center;">
                                        <div style="margin-bottom: 15px;">
                                            <img src="https://js.arcgis.com/4.33/esri/themes/base/images/Loading_Indicator.gif" alt="Loading..." width="20" height="20" />
                                        </div>
                                        <p style="font-size: 14px; color: #666; margin: 0;">
                                            G√©ocodage en cours...
                                        </p>
                                    </div>
                                `,
                                location: point
                            });
                            
                            // Faire le g√©ocodage en arri√®re-plan comme pour les clics manuels
                            performGeocoding(point.latitude, point.longitude, graphic);
                            
                            console.log('‚úÖ Carte centr√©e sur:', result.name, 'g√©ocodage en cours...');
                        }
                    }
                });
                
                // Cr√©er le PopupTemplate pour afficher les informations de g√©ocodage
                const popupTemplate = new PopupTemplate({
                    title: "üìç Informations de localisation",
                    content: [
                        {
                            type: "fields",
                            fieldInfos: [
                                {
                                    fieldName: "address",
                                    label: "Adresse",
                                    visible: true
                                },
                                {
                                    fieldName: "latitude",
                                    label: "Latitude",
                                    visible: true
                                },
                                {
                                    fieldName: "longitude",
                                    label: "Longitude",
                                    visible: true
                                }
                            ]
                        }
                    ]
                });
                
                // Configuration des clics sur graphics int√©gr√©e dans le handler principal
                
                view.when(() => {
                    console.log('‚úÖ Carte ArcGIS VF initialis√©e !');
                    
                    // Notifier le parent (LWC) que la carte est pr√™te
                    if (window.parent) {
                        window.parent.postMessage({
                            type: 'MAP_READY',
                            message: 'ArcGIS map initialized successfully'
                        }, '*');
                    }
                });
                
                // HANDLER DE CLIC - D√âSACTIV√â EN LECTURE SEULE
                view.on("click", function(event) {
                    if (window.isReadOnlyMode) {
                        console.log('üîí Lecture seule - clic ignor√©');
                        return;
                    }
                    console.log('üñ±Ô∏è Clic d√©tect√© sur la carte - mode natif ArcGIS');
                    
                    // Si un outil de cr√©ation Sketch est actif, laisser Sketch g√©rer
                    if (window.isSketchCreateMode) {
                        console.log('üé® Mode cr√©ation Sketch activ√© - g√©ocodage suspendu');
                        return;
                    }
                    
                    // Si le popup auto est d√©sactiv√© (mode dessin), ne pas g√©ocoder
                    if (view && view.popup && view.popup.autoOpenEnabled === false) {
                        console.log('üõë Popup d√©sactiv√© pour dessin - clic ignor√©');
                        return;
                    }
                    
                    // Si le widget Sketch existe et qu'un outil de cr√©ation est s√©lectionn√©, ne pas interf√©rer
                    if (window.sketchWidget) {
                        const vm = window.sketchWidget.viewModel || {};
                        const activeTool = window.sketchWidget.activeTool || vm.activeTool;
                        const state = vm.state;
                        if (activeTool) {
                            console.log('üé® Outil Sketch actif (', activeTool, ') - g√©ocodage suspendu');
                        return; // Laisser le widget Sketch g√©rer le clic
                        }
                        if (state !== "ready" && state !== "disabled") {
                            console.log('üé® Widget Sketch actif (state:', state, ') - g√©ocodage suspendu');
                            return;
                        }
                    }
                    
                    console.log('‚úÖ Mode navigation natif - g√©ocodage sur clic activ√©');
                    
                    const coords = {
                        longitude: event.mapPoint.longitude,
                        latitude: event.mapPoint.latitude
                    };
                    
                    console.log('üìç Coordonn√©es:', coords);
                    
                    // Envoyer les coordonn√©es au parent (LWC)
                    if (window.parent) {
                        window.parent.postMessage({
                            type: 'MAP_CLICK',
                            coordinates: coords
                        }, '*');
                        console.log('üì® Message envoy√© au parent LWC');
                    }
                    
                    // Cr√©er un point pour le popup
                    const point = new Point({
                        longitude: event.mapPoint.longitude,
                        latitude: event.mapPoint.latitude
                    });
                    
                    // Cr√©er un marqueur temporaire
                    const symbol = new SimpleMarkerSymbol({
                        color: [226, 119, 40],
                        outline: {
                            color: [255, 255, 255],
                            width: 2
                        }
                    });
                    
                    // Cr√©er le graphic avec le popup
                    const graphic = new Graphic({
                        geometry: point,
                        symbol: symbol,
                        popupTemplate: popupTemplate,
                        attributes: {
                            latitude: coords.latitude.toFixed(6),
                            longitude: coords.longitude.toFixed(6),
                            address: "G√©ocodage en cours..."
                        }
                    });
                    
                    // Nettoyer les anciens marqueurs et ajouter le nouveau
                    view.graphics.removeAll();
                    view.graphics.add(graphic);
                    
                    // Ouvrir imm√©diatement le popup avec "G√©ocodage en cours..."
                    view.openPopup({
                        title: "üìç Adresse",
                        content: `
                            <div style="padding: 15px; text-align: center;">
                                <div style="margin-bottom: 15px;">
                                    <img src="https://js.arcgis.com/4.33/esri/themes/base/images/Loading_Indicator.gif" alt="Loading..." width="20" height="20" />
                                </div>
                                <p style="font-size: 14px; color: #666; margin: 0;">
                                    G√©ocodage en cours...
                                </p>
                            </div>
                        `,
                        location: point
                    });
                    
                    // Faire le g√©ocodage en arri√®re-plan
                    performGeocoding(coords.latitude, coords.longitude, graphic);
                    
                    console.log('‚úÖ G√©ocodage d√©marr√© - popup ouvert');
                }, { passive: false }); // √âv√©nement non-passif pour permettre preventDefault si n√©cessaire
                
                // Fonction de g√©ocodage
                function performGeocoding(latitude, longitude, graphic) {
                    console.log('üåç D√©but g√©ocodage pour:', latitude, longitude);
                    
                    // Appel √† l'API ArcGIS Geocoding
                    const geocodeUrl = `https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/reverseGeocode?location=${longitude},${latitude}&outSR=4326&returnIntersection=false&f=json`;
                    
                    fetch(geocodeUrl)
                        .then(response => response.json())
                        .then(data => {
                            console.log('‚úÖ R√©ponse g√©ocodage:', data);
                            
                            if (data.address) {
                                const address = formatAddress(data.address);
                                console.log('üè† Adresse format√©e:', address);
                                
                                // Mettre √† jour le graphic avec l'adresse
                                graphic.attributes.address = address;
                                
                                console.log('‚úÖ Adresse mise √† jour dans le graphic');
                                
                                // Ouvrir automatiquement le popup avec l'adresse
                                view.openPopup({
                                    title: "üìç Adresse",
                                    content: `
                                        <div style="padding: 20px; text-align: center;">
                                            <div style="font-size: 16px; line-height: 1.4; color: #333;">
                                                ${address}
                                            </div>
                                        </div>
                                    `,
                                    location: graphic.geometry
                                });
                                
                                console.log('üéØ Popup ouvert automatiquement avec l\'adresse');
                                
                                // NOTIFIER LE LWC QU'UNE ADRESSE EST S√âLECTIONN√âE (comme une forme dessin√©e)
                                if (window.parent) {
                                    window.parent.postMessage({
                                        type: 'ADDRESS_SELECTED',
                                        address: {
                                            type: 'Adresse',
                                            coordinates: [{
                                                latitude: parseFloat(graphic.attributes.latitude),
                                                longitude: parseFloat(graphic.attributes.longitude)
                                            }],
                                            center: {
                                                latitude: parseFloat(graphic.attributes.latitude),
                                                longitude: parseFloat(graphic.attributes.longitude)
                                            },
                                            address: address,
                                            isAddress: true // Flag pour identifier les adresses
                                        }
                                    }, '*');
                                    
                                    console.log('üì® Message ADDRESS_SELECTED envoy√© au parent LWC avec adresse:', address);
                                    
                                    // ENVOYER AUSSI SHAPE_SELECTED pour activer le bouton Save
                                    window.parent.postMessage({
                                        type: 'SHAPE_SELECTED',
                                        shape: {
                                            type: 'Point',
                                            coordinates: [{
                                                latitude: parseFloat(graphic.attributes.latitude),
                                                longitude: parseFloat(graphic.attributes.longitude)
                                            }],
                                            center: {
                                                latitude: parseFloat(graphic.attributes.latitude),
                                                longitude: parseFloat(graphic.attributes.longitude)
                                            },
                                            address: address,
                                            isAddress: true
                                        }
                                    }, '*');
                                    console.log('üì® Message SHAPE_SELECTED envoy√© pour activer le bouton Save');
                                }
                            } else {
                                console.log('‚ö†Ô∏è Aucune adresse trouv√©e');
                                graphic.attributes.address = "Adresse non trouv√©e";
                                
                                // NOTIFIER LE LWC QU'UNE ADRESSE EST S√âLECTIONN√âE (m√™me sans adresse)
                                if (window.parent) {
                                    window.parent.postMessage({
                                        type: 'ADDRESS_SELECTED',
                                        address: {
                                            type: 'Adresse',
                                            coordinates: [{
                                                latitude: parseFloat(graphic.attributes.latitude),
                                                longitude: parseFloat(graphic.attributes.longitude)
                                            }],
                                            center: {
                                                latitude: parseFloat(graphic.attributes.latitude),
                                                longitude: parseFloat(graphic.attributes.longitude)
                                            },
                                            address: "Adresse non trouv√©e",
                                            isAddress: true // Flag pour identifier les adresses
                                        }
                                    }, '*');
                                    
                                    console.log('üì® Message ADDRESS_SELECTED envoy√© au parent LWC (sans adresse)');
                                    
                                    // ENVOYER AUSSI SHAPE_SELECTED pour activer le bouton Save
                                    window.parent.postMessage({
                                        type: 'SHAPE_SELECTED',
                                        shape: {
                                            type: 'Point',
                                            coordinates: [{
                                                latitude: parseFloat(graphic.attributes.latitude),
                                                longitude: parseFloat(graphic.attributes.longitude)
                                            }],
                                            center: {
                                                latitude: parseFloat(graphic.attributes.latitude),
                                                longitude: parseFloat(graphic.attributes.longitude)
                                            },
                                            address: "Adresse non trouv√©e",
                                            isAddress: true
                                        }
                                    }, '*');
                                    console.log('üì® Message SHAPE_SELECTED envoy√© pour activer le bouton Save (sans adresse)');
                                }
                                
                                // Ouvrir popup avec message d'erreur
                                view.openPopup({
                                    title: "üìç Adresse",
                                    content: `
                                        <div style="padding: 20px; text-align: center;">
                                            <div style="font-size: 16px; color: #d73a49; margin-bottom: 10px;">
                                                ‚ö†Ô∏è Adresse non trouv√©e
                                            </div>
                                            <div style="font-size: 14px; color: #666;">
                                                Impossible de r√©cup√©rer l'adresse pour ces coordonn√©es
                                            </div>
                                        </div>
                                    `,
                                    location: graphic.geometry
                                });
                            }
                        })
                        .catch(error => {
                            console.error('‚ùå Erreur g√©ocodage:', error);
                            graphic.attributes.address = "Erreur de g√©ocodage";
                            
                            // Ouvrir popup avec message d'erreur
                            view.openPopup({
                                title: "üìç Adresse",
                                content: `
                                    <div style="padding: 20px; text-align: center;">
                                        <div style="font-size: 16px; color: #d73a49; margin-bottom: 10px;">
                                            ‚ùå Erreur de g√©ocodage
                                        </div>
                                        <div style="font-size: 14px; color: #666;">
                                            Impossible de r√©cup√©rer l'adresse
                                        </div>
                                    </div>
                                `,
                                location: graphic.geometry
                            });
                        });
                }
                
                // Fonction de formatage d'adresse
                function formatAddress(addressData) {
                    const parts = [];
                    
                    if (addressData.Address) parts.push(addressData.Address);
                    if (addressData.City) parts.push(addressData.City);
                    if (addressData.Region) parts.push(addressData.Region);
                    if (addressData.Postal) parts.push(addressData.Postal);
                    if (addressData.CountryCode) parts.push(addressData.CountryCode);
                    
                    return parts.length > 0 ? parts.join(', ') : 'Adresse non disponible';
                }
                
                // Fonction pour sauvegarder une forme
                function handleSaveShape(data) {
                    console.log('üíæ D√©but de la sauvegarde de forme');
                    
                    try {
                        // R√©cup√©rer toutes les formes disponibles (sketch + g√©ocodage)
                        let graphics = [];
                        
                        // 1. V√©rifier les graphiques du sketch widget
                        if (sketchWidget && sketchWidget.view && sketchWidget.view.graphics) {
                            const sketchGraphics = sketchWidget.view.graphics.filter(g => g.geometry);
                            graphics = graphics.concat(sketchGraphics.toArray());
                            console.log('üìä Graphiques sketch trouv√©s:', sketchGraphics.length);
                        }
                        
                        // 2. V√©rifier les graphiques de la vue principale (g√©ocodage)
                        if (view && view.graphics) {
                            const viewGraphics = view.graphics.filter(g => g.geometry);
                            graphics = graphics.concat(viewGraphics.toArray());
                            console.log('üìä Graphiques view trouv√©s:', viewGraphics.length);
                        }
                        
                        // 3. V√©rifier le sketch layer
                        if (sketchLayer && sketchLayer.graphics) {
                            const layerGraphics = sketchLayer.graphics.filter(g => g.geometry);
                            graphics = graphics.concat(layerGraphics.toArray());
                            console.log('üìä Graphiques layer trouv√©s:', layerGraphics.length);
                        }
                        
                        console.log('üìä Total graphiques trouv√©s:', graphics.length);
                        
                        if (graphics.length === 0) {
                            console.warn('‚ö†Ô∏è Aucune forme √† sauvegarder');
                            notifyParent('SAVE_ERROR', { error: 'Aucune forme √† sauvegarder' });
                            return;
                        }
                        
                        // Prendre la derni√®re forme cr√©√©e
                        const graphic = graphics[graphics.length - 1];
                        console.log('üéØ Graphic s√©lectionn√© pour sauvegarde:', graphic);
                        
                        if (!graphic || !graphic.geometry) {
                            console.error('‚ùå Graphic invalide ou sans g√©om√©trie');
                            notifyParent('SAVE_ERROR', { error: 'Forme invalide' });
                            return;
                        }
                        
                        const shapeInfo = extractShapeInfo(graphic);
                        
                        console.log('üìä Informations de la forme √† sauvegarder:', shapeInfo);
                        
                        // Pr√©parer les donn√©es pour l'Apex
                        const mapAreaData = {
                            Area_Type__c: shapeInfo.type,
                            Geometry_JSON__c: JSON.stringify(convertToGeoJSON(shapeInfo)),
                            Latitude__c: shapeInfo.center ? shapeInfo.center.latitude : null,
                            Longitude__c: shapeInfo.center ? shapeInfo.center.longitude : null,
                            Address__c: shapeInfo.address || null
                        };
                        
                        console.log('üì§ Donn√©es √† envoyer √† Apex:', mapAreaData);
                        
                        // Appeler l'Apex via Remoting
                        saveMapAreaRemote(mapAreaData, data.champRelation, data.idParent);
                        
                    } catch (error) {
                        console.error('‚ùå Erreur lors de la pr√©paration de sauvegarde:', error);
                        notifyParent('SAVE_ERROR', { error: error.message });
                    }
                }
                
                // Fonction pour effacer la forme courante
                function clearCurrentShape() {
                    if (sketchWidget) {
                        sketchWidget.cancel();
                        const graphics = sketchWidget.view.graphics.filter(g => g.geometry);
                        if (graphics.length > 0) {
                            sketchWidget.view.graphics.remove(graphics[graphics.length - 1]);
                        }
                        notifyParent('NO_SHAPE_SELECTED');
                    }
                }
                
                // Fonction pour effacer toutes les formes
                function clearAllShapes() {
                    if (sketchWidget) {
                        sketchWidget.cancel();
                        // Nettoyer les graphiques de la vue principale
                        if (view && view.graphics) {
                            view.graphics.removeAll();
                        }
                        // Nettoyer le layer de sketch (mais pas savedLayer)
                        sketchLayer.removeAll();
                        // Fermer tout popup ouvert
                        if (view && view.popup) {
                            if (typeof view.popup.close === 'function') { view.popup.close(); } else { view.popup.visible = false; }
                        }
                        
                        notifyParent('NO_SHAPE_SELECTED');
                    }
                }
                
                // generateMapAreaName n'est plus utilis√© (Name standard auto)
                
                // Fonction pour convertir en GeoJSON
                function convertToGeoJSON(shapeInfo) {
                    if (shapeInfo.type === 'Point') {
                        return {
                            type: "Feature",
                            geometry: {
                                type: 'Point',
                                coordinates: [shapeInfo.coordinates[0].longitude, shapeInfo.coordinates[0].latitude]
                            },
                            properties: {
                                originalType: shapeInfo.type,
                                address: shapeInfo.address,
                                isCircle: shapeInfo.isCircle || false
                            }
                        };
                    } else if (shapeInfo.type === 'Polyline') {
                        return {
                            type: "Feature",
                            geometry: {
                                type: 'LineString',
                                coordinates: shapeInfo.coordinates.map(c => [c.longitude, c.latitude])
                            },
                            properties: {
                                originalType: shapeInfo.type,
                                address: shapeInfo.address,
                                isCircle: false
                            }
                        };
                    } else {
                        // Polygon / Rectangle (anneau unique)
                        return {
                            type: "Feature",
                            geometry: {
                                type: 'Polygon',
                                coordinates: [shapeInfo.coordinates.map(c => [c.longitude, c.latitude])]
                            },
                            properties: {
                                originalType: shapeInfo.type,
                                address: shapeInfo.address,
                                isCircle: shapeInfo.isCircle || false
                            }
                        };
                    }
                }
                
                // Fonction pour notifier le parent LWC
                function notifyParent(type, data = {}) {
                    if (window.parent) {
                        window.parent.postMessage({ type, data }, '*');
                    }
                }
                
                // Fonction Apex Remoting pour sauvegarder
                function saveMapAreaRemote(mapAreaData, champRelation, idParent) {
                    console.log('üöÄ Pr√©paration des donn√©es de sauvegarde (renvoi au LWC)');

                    try {
                        // Construire le payload ShapeData attendu par l'Apex LWC
                        const shapeData = {
                            areaType: mapAreaData.Area_Type__c,
                            geoJson: mapAreaData.Geometry_JSON__c,
                            latitude: mapAreaData.Latitude__c,
                            longitude: mapAreaData.Longitude__c,
                            address: mapAreaData.Address__c
                        };

                        console.log('üìã ShapeData renvoy√© au LWC:', shapeData);

                        // Notifier le parent (LWC) pour qu'il appelle l'Apex
                        if (window.parent) {
                            window.parent.postMessage({
                                type: 'SHAPE_DATA',
                                data: { shapeData }
                            }, '*');
                        }
                    } catch (error) {
                        console.error('‚ùå Erreur lors de la pr√©paration des donn√©es de sauvegarde:', error);
                        notifyParent('SAVE_ERROR', { error: error.message || 'Erreur de pr√©paration des donn√©es' });
                    }
                }
                
                // √âcouter les messages du parent (LWC)
                window.addEventListener('message', function(event) {
                    console.log('üì® Message re√ßu du LWC:', event.data);
                    
                    if (event.data.type === 'CENTER_MAP') {
                        view.center = [event.data.longitude, event.data.latitude];
                        if (event.data.zoom) {
                            view.zoom = event.data.zoom;
                        }
                    } else if (event.data.type === 'DISPLAY_SAVED_SHAPE') {
                        displaySavedShape(event.data);
                    } else if (event.data.type === 'SAVE_SHAPE') {
                        console.log('üíæ Demande de sauvegarde re√ßue');
                        handleSaveShape(event.data.data);
                    } else if (event.data.type === 'CLEAR_SHAPE') {
                        console.log('üßπ Demande d\'effacement de forme');
                        clearCurrentShape();
                    } else if (event.data.type === 'CLEAR_ALL') {
                        console.log('üßπ Demande d\'effacement total');
                        clearAllShapes();
                    } else if (event.data.type === 'GEOCODE_REQUEST') {
                        console.log('üåç Demande de g√©ocodage re√ßue:', event.data.coordinates);
                        
                        // Cr√©er un point pour le popup
                        const point = new Point({
                            longitude: event.data.coordinates.longitude,
                            latitude: event.data.coordinates.latitude
                        });
                        
                        // Cr√©er le graphic avec le popup
                        const graphic = new Graphic({
                            geometry: point,
                            symbol: new SimpleMarkerSymbol({
                                color: [226, 119, 40],
                                outline: { color: [255, 255, 255], width: 2 }
                            }),
                            popupTemplate: popupTemplate,
                            attributes: {
                                latitude: event.data.coordinates.latitude.toFixed(6),
                                longitude: event.data.coordinates.longitude.toFixed(6),
                                address: "G√©ocodage en cours..."
                            }
                        });
                        
                        // Nettoyer et ajouter le nouveau marqueur
                        view.graphics.removeAll();
                        view.graphics.add(graphic);
                        
                        // Ouvrir imm√©diatement le popup avec "G√©ocodage en cours..."
                        view.openPopup({
                            title: "üìç Adresse",
                            content: `
                                <div style="padding: 15px; text-align: center;">
                                    <div style="margin-bottom: 15px;">
                                        <img src="https://js.arcgis.com/4.33/esri/themes/base/images/Loading_Indicator.gif" alt="Loading..." width="20" height="20" />
                                    </div>
                                    <p style="font-size: 20px; color: #666; margin: 0;">
                                        G√©ocodage en cours...
                                    </p>
                                </div>
                            `,
                            location: point
                        });
                        
                        // Faire le g√©ocodage
                        performGeocoding(event.data.coordinates.latitude, event.data.coordinates.longitude, graphic);
                        
                        console.log('‚úÖ Popup ouvert depuis LWC, g√©ocodage en cours');
                    } else if (event.data.type === 'GET_CURRENT_SHAPE') {
                        console.log('üéØ Demande de forme actuelle re√ßue');
                        
                        // R√©cup√©rer toutes les formes du sketchLayer
                        const allGraphics = sketchLayer.graphics.toArray();
                        console.log('üé® Formes disponibles:', allGraphics.length);
                        
                        if (allGraphics.length > 0) {
                            // Extraire les informations de toutes les formes
                            const shapes = allGraphics.map(graphic => extractShapeInfo(graphic));
                            
                            // Envoyer la r√©ponse au LWC
                            if (window.parent) {
                                window.parent.postMessage({
                                    type: 'CURRENT_SHAPES_RESPONSE',
                                    shapes: shapes,
                                    totalCount: shapes.length
                                }, '*');
                            }
                            
                            console.log('üì® R√©ponse envoy√©e au LWC:', shapes);
                        } else {
                            // Aucune forme disponible
                            if (window.parent) {
                                window.parent.postMessage({
                                    type: 'CURRENT_SHAPES_RESPONSE',
                                    shapes: [],
                                    totalCount: 0
                                }, '*');
                            }
                            
                            console.log('üì® R√©ponse envoy√©e au LWC: Aucune forme');
                        }
                    } else if (event.data.type === 'CLEAR_SELECTION') {
                        console.log('üóëÔ∏è Demande de d√©s√©lection re√ßue');
                        
                        // D√©s√©lectionner toutes les formes
                        if (sketchWidget && sketchWidget.view) {
                            sketchWidget.view.graphics.forEach(graphic => {
                                graphic.selected = false;
                            });
                        }
                        
                        // Notifier le LWC que la s√©lection est vide
                        if (window.parent) {
                            window.parent.postMessage({
                                type: 'NO_SHAPE_SELECTED'
                            }, '*');
                        }
                        
                        console.log('‚úÖ S√©lection de la carte vid√©e');
                    } else if (event.data.type === 'ACTIVATE_DRAWING_MODE') {
                        console.log('üé® Activation du mode dessin demand√©e');
                        
                        // Cr√©er et activer le widget Sketch
                        createAndActivateSketchWidget();
                        
                    } else if (event.data.type === 'DEACTIVATE_DRAWING_MODE') {
                        console.log('üñ±Ô∏è D√©sactivation du mode dessin - retour natif ArcGIS');
                        
                        // D√©sactiver le widget Sketch et revenir au mode natif
                        deactivateSketchWidget();
                        
                    } else if (event.data.type === 'SET_DRAWING_MODE') {
                        console.log('üîß Changement de mode de dessin:', event.data.tool);
                        
                        // S'assurer que le widget existe
                        if (!window.sketchWidget) {
                            createAndActivateSketchWidget();
                        }
                        
                        // Activer l'outil sp√©cifique
                        if (window.sketchWidget) {
                            setDrawingMode(event.data.tool);
                        }
                        
                    } else if (event.data.type === 'UNDO_LAST_SHAPE') {
                        console.log('‚Ü∂ Annulation de la derni√®re forme');
                        undoLastShape();
                    }
                });
                
                // Fonction pour changer le mode de dessin
                function setDrawingMode(tool) {
                    if (!window.sketchWidget) {
                        console.warn('‚ö†Ô∏è SketchWidget pas encore initialis√©');
                        return;
                    }
                    
                    try {
                        // D√©sactiver d'abord tous les outils
                        window.sketchWidget.cancel();
                        
                        if (tool === 'select') {
                            // Mode s√©lection - pas d'outil actif
                            console.log('‚úã Mode s√©lection activ√©');
                        } else {
                            // Activer l'outil demand√©
                            const toolMapping = {
                                'point': 'point',
                                'polyline': 'polyline', 
                                'polygon': 'polygon',
                                'rectangle': 'rectangle',
                                'circle': 'circle'
                            };
                            
                            const sketchTool = toolMapping[tool];
                            if (sketchTool) {
                                // V√âRIFIER QUE L'OUTIL EST AUTORIS√â DANS LA CONFIGURATION
                                if (window.sketchConfig && window.sketchConfig[sketchTool + 'Tool']) {
                                    window.sketchWidget.create(sketchTool);
                                    console.log('üé® Outil activ√©:', sketchTool);
                                } else {
                                    console.warn('‚ö†Ô∏è Outil non autoris√© dans la configuration:', sketchTool);
                                    // Revenir au mode s√©lection
                                    window.sketchWidget.cancel();
                                }
                            } else {
                                console.warn('‚ö†Ô∏è Outil non reconnu:', tool);
                            }
                        }
                        
                        // Mettre √† jour le compteur
                        updateShapeCount();
                        
                    } catch (error) {
                        console.error('‚ùå Erreur lors du changement d\'outil:', error);
                    }
                }
                
                // Fonction pour mettre √† jour dynamiquement la configuration des outils
                function updateDrawingToolsConfig() {
                    console.log('üîÑ Mise √† jour dynamique de la configuration des outils...');
                    
                    // Recharger la configuration depuis Custom Settings
                    loadDrawingToolsConfig().then(newConfig => {
                        console.log('‚úÖ Nouvelle configuration charg√©e:', newConfig);
                        
                        // Mettre √† jour la configuration globale
                        window.sketchConfig = newConfig;
                        
                        // Mettre √† jour le widget Sketch si il existe
                        if (window.sketchWidget) {
                            console.log('üîß Mise √† jour du widget Sketch avec la nouvelle configuration');
                            
                            // Recr√©er le widget avec la nouvelle configuration
                            deactivateSketchWidget();
                            createAndActivateSketchWidget();
                        }
                        
                    }).catch(error => {
                        console.error('‚ùå Erreur lors de la mise √† jour de la configuration:', error);
                    });
                }
                
                // Fonction pour annuler la derni√®re forme
                function undoLastShape() {
                    if (!sketchLayer) {
                        console.warn('‚ö†Ô∏è SketchLayer pas encore initialis√©');
                        return;
                    }
                    
                    try {
                        const graphics = sketchLayer.graphics;
                        if (graphics.length > 0) {
                            // Supprimer la derni√®re forme ajout√©e
                            const lastGraphic = graphics.getItemAt(graphics.length - 1);
                            sketchLayer.remove(lastGraphic);
                            console.log('üóëÔ∏è Derni√®re forme supprim√©e');
                            
                            // Mettre √† jour le compteur
                            updateShapeCount();
                        } else {
                            console.log('‚ÑπÔ∏è Aucune forme √† annuler');
                        }
                    } catch (error) {
                        console.error('‚ùå Erreur lors de l\'annulation:', error);
                    }
                }
                
                // Fonction pour mettre √† jour le compteur de formes
                function updateShapeCount() {
                    if (!sketchLayer) return;
                    
                    const totalCount = sketchLayer.graphics.length;
                    const selectedCount = sketchLayer.graphics.filter(g => g.selected).length;
                    
                    // Envoyer la mise √† jour au LWC
                    if (window.parent) {
                        window.parent.postMessage({
                            type: 'SHAPE_COUNT_UPDATE',
                            totalCount: totalCount,
                            selectedCount: selectedCount
                        }, '*');
                    }
                    
                    console.log(`üìä Compteur mis √† jour: ${totalCount} formes, ${selectedCount} s√©lectionn√©es`);
                }
                
                // Fonction pour configurer les styles de highlight
                function setupHighlightStyles() {
                    // Configurer les styles des formes s√©lectionn√©es
                    if (sketchWidget && sketchWidget.viewModel) {
                        // Style pour les formes s√©lectionn√©es
                        const selectedStyle = {
                            color: [255, 165, 0, 0.8], // Orange avec transparence
                            outline: {
                                color: [255, 100, 0, 1], // Orange fonc√© pour le contour
                                width: 3
                            }
                        };
                        
                        // Style pour les formes non s√©lectionn√©es
                        const normalStyle = {
                            color: [0, 122, 194, 0.6], // Bleu ArcGIS avec transparence
                            outline: {
                                color: [0, 122, 194, 1], // Bleu ArcGIS pour le contour
                                width: 2
                            }
                        };
                        
                        console.log('üé® Styles de highlight configur√©s');
                        
                        // √âcouter les changements de s√©lection pour appliquer les styles
                        sketchWidget.on("select", function(event) {
                            applyHighlightStyles();
                        });
                        
                        sketchWidget.on("update", function(event) {
                            if (event.state === "complete") {
                                applyHighlightStyles();
                            }
                        });
                    }
                }
                
                // Fonction pour appliquer les styles de highlight
                function applyHighlightStyles() {
                    if (!sketchLayer) return;
                    
                    sketchLayer.graphics.forEach(graphic => {
                        if (graphic.selected) {
                            // Style pour les formes s√©lectionn√©es (orange)
                            if (graphic.geometry.type === 'point') {
                                graphic.symbol = {
                                    type: "simple-marker",
                                    color: [255, 165, 0, 0.8],
                                    outline: {
                                        color: [255, 100, 0, 1],
                                        width: 3
                                    },
                                    size: 12
                                };
                            } else {
                                graphic.symbol = {
                                    type: graphic.geometry.type === 'polyline' ? "simple-line" : "simple-fill",
                                    color: [255, 165, 0, 0.3],
                                    outline: {
                                        color: [255, 100, 0, 1],
                                        width: 3
                                    }
                                };
                            }
                        } else {
                            // Style pour les formes normales (bleu)
                            if (graphic.geometry.type === 'point') {
                                graphic.symbol = {
                                    type: "simple-marker",
                                    color: [0, 122, 194, 0.8],
                                    outline: {
                                        color: [0, 122, 194, 1],
                                        width: 2
                                    },
                                    size: 10
                                };
                            } else {
                                graphic.symbol = {
                                    type: graphic.geometry.type === 'polyline' ? "simple-line" : "simple-fill",
                                    color: [0, 122, 194, 0.2],
                                    outline: {
                                        color: [0, 122, 194, 1],
                                        width: 2
                                    }
                                };
                            }
                        }
                    });
                    
                    console.log('üé® Styles de highlight appliqu√©s');
                }

                // Afficher une forme sauvegard√©e dans le layer d√©di√© et la mettre en √©vidence
                function displaySavedShape(data) {
                    try {
                        const geometryData = data.geometryData; // GeoJSON string
                        const feature = typeof geometryData === 'string' ? JSON.parse(geometryData) : geometryData;
                        const areaType = data.areaType;
                        
                        // Cr√©er le graphic selon type
                        let graphic = null;
                        switch (areaType) {
                            case 'Point':
                                graphic = createReadOnlyPointGraphic(feature);
                                break;
                            case 'Polyline':
                                graphic = createReadOnlyPolylineGraphic(feature);
                                break;
                            case 'Polygon':
                            case 'Rectangle':
                            case 'Circle':
                                graphic = createReadOnlyPolygonGraphic(feature);
                                break;
                        }
                        if (!graphic) return;
                        
                        // Option: style de mise en √©vidence
                        if (graphic.symbol && graphic.symbol.outline) {
                            graphic.symbol.outline.width = 3;
                        }
                        
                        // Ajouter/mettre en avant
                        savedLayer.add(graphic);
                        
                        // Centrer la vue
                        if (data.autoCenter) {
                            const extent = graphic.geometry.extent || graphic.geometry;
                            view.goTo({ target: extent, zoom: extent.type === 'point' ? 16 : undefined });
                        }
                    } catch (e) {
                        console.error('‚ùå Erreur displaySavedShape:', e);
                    }
                }
            });
            

            
            // Fonction pour afficher une g√©om√©trie en mode lecture seule
            function displayReadOnlyGeometry(data) {
                console.log('üìç Affichage g√©om√©trie en mode lecture seule:', data);
                
                try {
                    const geometryData = data.geometryData;
                    const feature = JSON.parse(geometryData);
                    
                    // Effacer les graphiques existants
                    sketchLayer.removeAll();
                    
                    let graphic = null;
                    
                    // Cr√©er le graphique selon le type de g√©om√©trie
                    switch (feature.properties.originalType || feature.properties.shapeType) {
                        case 'Circle':
                            graphic = createReadOnlyCircleGraphic(feature, data.centerCoordinates);
                            break;
                        case 'Point':
                            graphic = createReadOnlyPointGraphic(feature);
                            break;
                        case 'Polygon':
                            graphic = createReadOnlyPolygonGraphic(feature);
                            break;
                        case 'Polyline':
                            graphic = createReadOnlyPolylineGraphic(feature);
                            break;
                        case 'Rectangle':
                            graphic = createReadOnlyRectangleGraphic(feature);
                            break;
                        default:
                            console.warn('‚ö†Ô∏è Type de g√©om√©trie non support√©:', feature.properties.originalType);
                    }
                    
                    if (graphic) {
                        // Ajouter √† la carte avec style lecture seule
                        sketchLayer.add(graphic);
                        
                        // Centrer la vue si demand√©
                        if (data.autoCenter) {
                            const extent = graphic.geometry.extent || graphic.geometry;
                            view.goTo({
                                target: extent,
                                zoom: extent.type === 'point' ? 16 : undefined
                            }).then(() => {
                                console.log('‚úÖ Vue centr√©e sur la g√©om√©trie');
                            });
                        }
                        
                        // D√©sactiver les outils de dessin en mode lecture seule
                        if (window.sketchWidget) {
                            window.sketchWidget.cancel();
                            window.sketchWidget.view = null; // D√©sactiver compl√®tement
                        }
                        
                        console.log('‚úÖ G√©om√©trie affich√©e en mode lecture seule');
                    }
                    
                } catch (error) {
                    console.error('‚ùå Erreur affichage g√©om√©trie lecture seule:', error);
                }
            }
            
            // Fonction pour cr√©er un cercle en lecture seule
            function createReadOnlyCircleGraphic(feature, centerCoordinates) {
                const radius = feature.properties.radius;
                let center;
                
                // Utiliser les coordonn√©es du centre si disponibles
                if (centerCoordinates && centerCoordinates.latitude && centerCoordinates.longitude) {
                    center = [centerCoordinates.longitude, centerCoordinates.latitude];
                } else if (feature.geometry.coordinates && feature.geometry.coordinates[0] && feature.geometry.coordinates[1]) {
                    center = feature.geometry.coordinates;
                } else {
                    console.warn('‚ö†Ô∏è Coordonn√©es du centre manquantes pour le cercle');
                    return null;
                }
                
                // Cr√©er le cercle
                const circle = new geometryEngine.geodesicBuffer(
                    new Point({
                        longitude: center[0],
                        latitude: center[1]
                    }),
                    radius,
                    'meters'
                );
                
                return new Graphic({
                    geometry: circle,
                    symbol: {
                        type: "simple-fill",
                        color: [51, 153, 255, 0.3], // Bleu clair transparent
                        outline: {
                            color: [51, 153, 255, 0.8], // Bleu plus fonc√©
                            width: 2
                        }
                    }
                });
            }
            
            // Fonction pour cr√©er un point en lecture seule
            function createReadOnlyPointGraphic(feature) {
                const coords = feature.geometry.coordinates;
                
                return new Graphic({
                    geometry: new Point({
                        longitude: coords[0],
                        latitude: coords[1]
                    }),
                    symbol: {
                        type: "simple-marker",
                        color: [51, 153, 255, 0.8],
                        outline: {
                            color: [51, 153, 255, 1],
                            width: 2
                        },
                        size: 12
                    }
                });
            }
            
            // Fonction pour cr√©er un polygone en lecture seule
            function createReadOnlyPolygonGraphic(feature) {
                return new Graphic({
                    geometry: {
                        type: "polygon",
                        rings: feature.geometry.coordinates
                    },
                    symbol: {
                        type: "simple-fill",
                        color: [51, 153, 255, 0.3],
                        outline: {
                            color: [51, 153, 255, 0.8],
                            width: 2
                        }
                    }
                });
            }
            
            // Fonction pour cr√©er une polyligne en lecture seule
            function createReadOnlyPolylineGraphic(feature) {
                return new Graphic({
                    geometry: {
                        type: "polyline",
                        paths: feature.geometry.coordinates
                    },
                    symbol: {
                        type: "simple-line",
                        color: [51, 153, 255, 0.8],
                        width: 3
                    }
                });
            }
            
            // Fonction pour cr√©er un rectangle en lecture seule
            function createReadOnlyRectangleGraphic(feature) {
                // Les rectangles sont stock√©s comme des polygones
                return createReadOnlyPolygonGraphic(feature);
            }
            
        </script>
    </body>
    </html>
</apex:page>
