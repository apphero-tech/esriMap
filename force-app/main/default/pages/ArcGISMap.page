<apex:page showHeader="false" sidebar="false" standardStylesheets="false" docType="html-5.0">
    <!-- Support Visualforce Remoting -->
    <apex:remoteObjects>
        <apex:remoteObjectModel name="ArcGIS_Tool_Settings__c" fields="Name,Tool_Type__c,Is_Enabled__c" />
    </apex:remoteObjects>
    
    <html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>ArcGIS Map</title>
        
        <!-- ArcGIS Maps SDK 4.33 -->
        <link rel="stylesheet" href="https://js.arcgis.com/4.33/esri/themes/light/main.css" />
        <script src="https://js.arcgis.com/4.33/init.js"></script>
        
        <style>
            html, body, #viewDiv {
                padding: 0;
                margin: 0;
                height: 100%;
                width: 100%;
                font-family: 'Avenir Next', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            }
            
            /* Espace entre Zoom et Locate lorsqu'ils sont en bas à gauche */
            .esri-ui-bottom-left .esri-locate { margin-top: 8px; }
            
            /* Style pour le widget Search */
            .esri-search {
                width: 300px;
                max-width: 90vw;
            }
            
            .esri-search__input {
                border-radius: 6px;
                border: 2px solid #e1e5e9;
                font-size: 14px;
                padding: 8px 12px;
                transition: border-color 0.2s ease;
            }
            
            .esri-search__input:focus {
                border-color: #0079c1;
                outline: none;
                box-shadow: 0 0 0 3px rgba(0, 121, 193, 0.1);
            }
            
            .esri-search__suggestions {
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                border: 1px solid #e1e5e9;
            }
            
            .esri-search__suggestion {
                padding: 10px 12px;
                border-bottom: 1px solid #f0f0f0;
                cursor: pointer;
                transition: background-color 0.2s ease;
            }
            
            .esri-search__suggestion:hover {
                background-color: #f8f9fa;
            }
            
            .esri-search__suggestion:last-child {
                border-bottom: none;
            }

            /* Masquer tous les contrôles ArcGIS (lecture seule) sauf Zoom */
            .esri-ui-corner,
            .esri-search,
            .esri-search-*,
            .esri-compass,
            .esri-compass-*,
            .esri-locate,
            .esri-locate-*,
            .esri-basemap-toggle,
            .esri-basemap-toggle-*,
            .esri-sketch,
            .esri-sketch-*,
            .esri-ui-manual-container { display: none !important; }
        </style>
    </head>
    <body>
        <div id="viewDiv"></div>
        
        <script>
            require([
                "esri/Map",
                "esri/views/MapView",
                "esri/geometry/Point",
                "esri/Graphic",
                "esri/symbols/SimpleMarkerSymbol",
                "esri/PopupTemplate",
                "esri/widgets/Popup",
                "esri/widgets/Search",
                "esri/widgets/Compass",
                "esri/widgets/Locate",
                "esri/widgets/BasemapToggle",
                "esri/widgets/Sketch",
                "esri/layers/GraphicsLayer",
                "esri/geometry/geometryEngine",
                "esri/geometry/support/webMercatorUtils",
                "esri/core/reactiveUtils"
            ], function(Map, MapView, Point, Graphic, SimpleMarkerSymbol, PopupTemplate, Popup, Search, Compass, Locate, BasemapToggle, Sketch, GraphicsLayer, geometryEngine, webMercatorUtils, reactiveUtils) {
                
                // ✅ INITIALISER LE CONTEXTE PAR DÉFAUT DÈS LE DÉBUT
                // Cela évite que recordId soit undefined si UPDATE_CONTEXT n'arrive pas assez vite
                window.lwcContext = {
                    recordId: null,
                    relationshipFieldName: null,
                    readOnly: false
                };
                
                
                // Créer la carte
                const map = new Map({
                    basemap: "streets-navigation-vector"
                });

                // Créer un GraphicsLayer dédié pour les dessins Sketch
                const sketchLayer = new GraphicsLayer({
                    title: "Dessins utilisateur"
                });
                map.add(sketchLayer);
                
                // Layer pour les formes enregistrées (persistantes le temps de la session)
                const savedLayer = new GraphicsLayer({
                    title: "Formes enregistrées"
                });
                map.add(savedLayer);
                
                // ========================================
                // FONCTIONNALITÉS MODE LECTURE SEULE
                // ========================================
                
                // Fonction pour afficher une géométrie en mode lecture seule
                function displayReadOnlyGeometry(data) {
                    try {
                        // Mettre à jour le mode global
                        window.isReadOnlyMode = data.readOnlyMode || false;
                        
                        // Gérer l'interface en mode lecture seule
                        if (window.isReadOnlyMode) {
                            toggleReadOnlyInterface(true);
                        }
                        
                        const geometryData = data.geometry || data.geometryData;
                        const feature = typeof geometryData === 'string' ? JSON.parse(geometryData) : geometryData;
                        
                        // Effacer les graphiques existants
                        sketchLayer.removeAll();
                        
                        let graphic = null;
                        
                        // Créer le graphique selon le type de géométrie
                        // Utiliser d'abord Area_Type__c du LWC, puis les propriétés GeoJSON
                        const geometryType = data.areaType || feature.properties.originalType || feature.properties.shapeType;
                        
                        switch (geometryType) {
                            case 'Circle':
                                graphic = createReadOnlyCircleGraphic(feature, data.centerCoordinates);
                                break;
                            case 'Point':
                                graphic = createReadOnlyPointGraphic(feature);
                                break;
                            case 'Polygon':
                                graphic = createReadOnlyPolygonGraphic(feature);
                                break;
                            case 'Polyline':
                                graphic = createReadOnlyPolylineGraphic(feature);
                                break;
                            case 'Rectangle':
                                graphic = createReadOnlyRectangleGraphic(feature);
                                break;
                            default:
                                console.warn('⚠️ Type de géométrie non supporté:', geometryType);
                        }
                        
                        // Si latitude/longitude fournies, forcer un point unique centré
                        if (data && typeof data.latitude === 'number' && typeof data.longitude === 'number') {
                            const pointGraphic = new Graphic({
                                geometry: new Point({ longitude: data.longitude, latitude: data.latitude }),
                                symbol: {
                                    type: "simple-marker",
                                    color: [51, 153, 255, 0.8],
                                    outline: { color: [255, 255, 255, 1], width: 2 },
                                    size: 12
                                }
                            });
                            sketchLayer.add(pointGraphic);
                            view.goTo({ target: pointGraphic.geometry, zoom: 16 }).then(() => {
                                try {
                                    // Figer la carte (pas de pan) avec un extent autour du point
                                    if (view && view.constraints) {
                                        const lon = pointGraphic.geometry.longitude;
                                        const lat = pointGraphic.geometry.latitude;
                                        const delta = 0.0002; // env. ~20m, selon SR
                                        const extent = new Extent({ xmin: lon - delta, ymin: lat - delta, xmax: lon + delta, ymax: lat + delta, spatialReference: { wkid: 4326 } });
                                        view.constraints = {
                                            rotationEnabled: false,
                                            snapToZoom: true,
                                            geometry: extent
                                        };
                                    }
                                    if (view && view.navigation) {
                                        // Désactiver zoom molette et pan tactile/ clavier
                                        view.navigation.mouseWheelZoomEnabled = false;
                                        view.navigation.browserTouchPanEnabled = false;
                                        view.navigation.gamepadEnabled = false;
                                        view.navigation.keyboardEnabled = false;
                                    }
                                    view.on("drag", function(evt){ evt.stopPropagation(); });
                                    view.on("mouse-wheel", function(evt){ evt.stopPropagation(); });
                                    view.on("double-click", function(evt){ evt.stopPropagation(); });
                                    view.on("pointer-down", function(evt){ if (window.isReadOnlyMode) evt.stopPropagation(); });
                                    view.on("immediate-click", function(evt){ evt.stopPropagation(); });
                                    view.on("pointer-move", function(evt){ evt.stopPropagation(); });

                                    // Ne pas bloquer les raccourcis de zoom du navigateur pour éviter les crashes Chrome
                                } catch (freezeErr) { console.warn('⚠️ Erreur lors du gel de la carte:', freezeErr); }
                            });
                            // Activer l'interface lecture seule
                            toggleReadOnlyInterface(true);
                            return;
                        }

                        if (graphic) {
                            // Ajouter à la carte avec style lecture seule
                            sketchLayer.add(graphic);
                            
                            // Centrer la vue si demandé
                            if (data && data.autoCenter) {
                                const extent = graphic.geometry.extent || graphic.geometry;
                                view.goTo({
                                    target: extent,
                                    zoom: extent.type === 'point' ? 16 : undefined
                                }).then(() => {
                                    try {
                                        if (view && view.constraints && graphic) {
                                            const geom = graphic.geometry;
                                            const extentGeom = geom.extent ? geom.extent : geom;
                                            view.constraints = {
                                                rotationEnabled: false,
                                                snapToZoom: true,
                                                geometry: extentGeom
                                            };
                                        }
                                        if (view && view.navigation) {
                                            view.navigation.mouseWheelZoomEnabled = false;
                                            view.navigation.browserTouchPanEnabled = false;
                                            view.navigation.gamepadEnabled = false;
                                            view.navigation.keyboardEnabled = false;
                                        }
                                        view.on("drag", function(evt){ evt.stopPropagation(); });
                                        view.on("mouse-wheel", function(evt){ evt.stopPropagation(); });
                                        view.on("double-click", function(evt){ evt.stopPropagation(); });
                                        view.on("pointer-down", function(evt){ if (window.isReadOnlyMode) evt.stopPropagation(); });
                                        view.on("immediate-click", function(evt){ evt.stopPropagation(); });
                                        view.on("pointer-move", function(evt){ evt.stopPropagation(); });

                                        // Ne pas installer de hook clavier global pour éviter les crashes
                                    } catch (freezeErr) { console.warn('⚠️ Erreur lors du gel de la carte:', freezeErr); }
                                });
                            }
                            
                            // Désactiver les outils de dessin en mode lecture seule
                            if (window.sketchWidget) {
                                window.sketchWidget.cancel();
                                window.sketchWidget.view = null; // Désactiver complètement
                            }
                            
                        }
                        
                    } catch (error) {
                        console.error('❌ Erreur affichage géométrie lecture seule:', error);
                    }
                }
                
                // Fonction pour créer un cercle en lecture seule
                function createReadOnlyCircleGraphic(feature, centerCoordinates) {
                    const radius = feature.properties.radius;
                    let center;
                    
                    // Utiliser les coordonnées du centre si disponibles
                    if (centerCoordinates && centerCoordinates.latitude && centerCoordinates.longitude) {
                        center = [centerCoordinates.longitude, centerCoordinates.latitude];
                    } else if (feature.geometry.coordinates && feature.geometry.coordinates[0] && feature.geometry.coordinates[1]) {
                        center = feature.geometry.coordinates;
                    } else {
                        console.warn('⚠️ Coordonnées du centre manquantes pour le cercle');
                        return null;
                    }
                    
                    // Créer le cercle
                    const circle = new geometryEngine.geodesicBuffer(
                        new Point({
                            longitude: center[0],
                            latitude: center[1]
                        }),
                        radius,
                        'meters'
                    );
                    
                    return new Graphic({
                        geometry: circle,
                        symbol: {
                            type: "simple-fill",
                            color: [51, 153, 255, 0.3], // Bleu clair transparent
                            outline: {
                                color: [51, 153, 255, 0.8], // Bleu plus foncé
                                width: 2
                            }
                        }
                    });
                }
                
                // Fonction pour créer un point en lecture seule
                function createReadOnlyPointGraphic(feature) {
                    const coords = feature.geometry.coordinates;
                    
                    return new Graphic({
                        geometry: new Point({
                            longitude: coords[0],
                            latitude: coords[1]
                        }),
                        symbol: {
                            type: "simple-marker",
                            color: [51, 153, 255, 0.8],
                            outline: {
                                color: [51, 153, 255, 1],
                                width: 2
                            },
                            size: 12
                        }
                    });
                }
                
                // Fonction pour créer un polygone en lecture seule
                function createReadOnlyPolygonGraphic(feature) {
                    return new Graphic({
                        geometry: {
                            type: "polygon",
                            rings: feature.geometry.coordinates
                        },
                        symbol: {
                            type: "simple-fill",
                            color: [51, 153, 255, 0.3],
                            outline: {
                                color: [51, 153, 255, 0.8],
                                width: 2
                            }
                        }
                    });
                }
                
                // Fonction pour créer une polyligne en lecture seule
                function createReadOnlyPolylineGraphic(feature) {
                    return new Graphic({
                        geometry: {
                            type: "polyline",
                            paths: feature.geometry.coordinates
                        },
                        symbol: {
                            type: "simple-line",
                            color: [51, 153, 255, 0.8],
                            width: 3
                        }
                    });
                }
                
                // Fonction pour créer un rectangle en lecture seule
                function createReadOnlyRectangleGraphic(feature) {
                    // Les rectangles sont stockés comme des polygones
                    return createReadOnlyPolygonGraphic(feature);
                }
                
                // Fonction pour gérer l'interface en mode lecture seule
                function toggleReadOnlyInterface(isReadOnly) {
                    
                    if (isReadOnly) {
                        // Mode lecture seule : supprimer les composants UI et widgets
                        try { if (typeof view !== 'undefined' && view && view.ui) { view.ui.components = ["zoom"]; } } catch (e) {}
                        // Retirer explicitement les widgets ajoutés à l'UI (on garde uniquement Zoom via components)
                        try { if (searchWidget) { view.ui.remove(searchWidget); } } catch (e) {}
                        try { if (compassWidget) { view.ui.remove(compassWidget); } } catch (e) {}
                        try { if (locateWidget) { view.ui.remove(locateWidget); } } catch (e) {}
                        try { if (basemapToggleWidget) { view.ui.remove(basemapToggleWidget); } } catch (e) {}
                        try { if (window.sketchWidget) { view.ui.remove(window.sketchWidget); } } catch (e) {}
                        
                        // Masquer le widget Search
                        if (searchWidget && searchWidget.container) {
                            searchWidget.container.style.display = 'none';
                        }
                        
                        // Masquer le widget Compass
                        if (compassWidget && compassWidget.container) {
                            compassWidget.container.style.display = 'none';
                        }
                        
                        // Masquer le widget Locate
                        if (locateWidget && locateWidget.container) {
                            locateWidget.container.style.display = 'none';
                        }
                        
                        // Masquer le widget BasemapToggle
                        if (basemapToggleWidget && basemapToggleWidget.container) {
                            basemapToggleWidget.container.style.display = 'none';
                        }
                        
                        // Masquer le widget Sketch
                        if (window.sketchWidget && window.sketchWidget.container) {
                            window.sketchWidget.container.style.display = 'none';
                        }
                        
                        
                    } else {
                        // Mode édition : afficher tous les widgets
                        
                        // Afficher le widget Search
                        if (searchWidget && searchWidget.container) {
                            searchWidget.container.style.display = 'block';
                        }
                        
                        // Afficher le widget Compass
                        if (compassWidget && compassWidget.container) {
                            compassWidget.container.style.display = 'block';
                        }
                        
                        // Afficher le widget Locate
                        if (locateWidget && locateWidget.container) {
                            locateWidget.container.style.display = 'block';
                        }
                        
                        // Afficher le widget BasemapToggle
                        if (basemapToggleWidget && basemapToggleWidget.container) {
                            basemapToggleWidget.container.style.display = 'block';
                        }
                        
                        // Afficher le widget Sketch
                        if (window.sketchWidget && window.sketchWidget.container) {
                            window.sketchWidget.container.style.display = 'block';
                        }
                        
                    }
                }
                
                // Créer la vue
                const view = new MapView({
                    container: "viewDiv",
                    map: map,
                    center: [-73.5673, 45.5017], // Place Ville-Marie, Montréal
                    zoom: 15,
                    constraints: {
                        rotationEnabled: true, // Activer la rotation pour le Compass
                        rotationAngle: 0 // Commencer avec l'orientation nord
                    }
                });
                

                // Essai simple de centrage sur géolocalisation si disponible
                if (navigator.geolocation) {
                    setTimeout(function() {
                        navigator.geolocation.getCurrentPosition(
                            function(position) {
                                var userCoords = [position.coords.longitude, position.coords.latitude];
                                console.log('✅ Position utilisateur:', userCoords);
                                view.goTo({ center: userCoords, zoom: 15 }, { duration: 1000 });
                            },
                            function(error) {
                                console.log('📌 Géolocalisation refusée, reste sur Montréal');
                            },
                            { timeout: 5000, maximumAge: 300000 }
                        );
                    }, 500);
                }
                
                                // ========================================
                // ÉCOUTEUR DE MESSAGES POUR MODE LECTURE SEULE
                // ========================================
                
                // Écouter les messages du composant LWC pour le mode lecture seule
                // ✅ IMPORTANT: Fonction nommée + détachement précédent pour éviter doublons
                window.removeEventListener('message', window.__vfReadOnlyHandler);
                window.__vfReadOnlyHandler = function(event) {
                    if (event.data && event.data.type === 'DISPLAY_READONLY_GEOMETRY') {
                        var payload = (event.data && event.data.data) ? event.data.data : event.data;
                        try { window.isReadOnlyMode = !!(payload && payload.readOnlyMode); } catch (e) {}
                        displayReadOnlyGeometry(payload);
                    }
                };
                window.addEventListener('message', window.__vfReadOnlyHandler);

                // Créer et configurer le widget Search avec autocomplétion (sans géolocalisation)
                const searchWidget = new Search({
                            view: view,
                            sources: [{
                                url: "https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer",
                                singleLineFieldName: "SingleLine",
                                name: "ArcGIS World Geocoding Service",
                        countryCode: "CAN", // Priorité au Canada
                        maxResults: 10,
                        maxSuggestions: 8,
                        minSuggestCharacters: 1,
                        searchExtent: view.extent
                    }],
                    autoComplete: true,
                    searchAllEnabled: false, // Désactiver la recherche globale pour éviter la géolocalisation
                    includeDefaultSources: false, // Exclure les sources par défaut (incluant géolocalisation)
                    locationEnabled: false, // Désactiver explicitement la géolocalisation dans Search
                    popupEnabled: false, // On gère nos propres popups
                    resultGraphicEnabled: false, // On gère nos propres graphics
                    container: "searchContainer"
                });
                
                // Variable globale pour le mode lecture seule
                window.isReadOnlyMode = false;

                // Créer et configurer le widget Compass (navigation)
                const compassWidget = new Compass({
                    view: view,
                    label: "Réinitialiser l'orientation nord"
                });

                // Écouter les changements de rotation pour informer l'utilisateur
                reactiveUtils.watch(() => view.rotation, function(rotation) {
                    if (Math.abs(rotation) > 1) { // Si rotation significative
                    }
                });

                // Écouter les clics sur le compass
                compassWidget.on("click", function() {
                });

                // Créer et configurer le widget Locate (géolocalisation native ArcGIS)
                const locateWidget = new Locate({
                    view: view,
                    label: "Ma position",
                    useHeadingEnabled: false
                    // ✅ TEST: Retirer temporairement goToOverride pour isoler le problème
                });

                // Créer et configurer le widget BasemapToggle (changement de fond de carte)
                const basemapToggleWidget = new BasemapToggle({
                            view: view,
                    nextBasemap: "satellite", // Vue satellite comme alternative
                    label: "Basculer vers satellite"
                });

                // NOUVELLE APPROCHE: Créer le widget Sketch SANS l'attacher à la vue
                // Cela préserve le comportement natif ArcGIS par défaut
                
                // Variable globale pour le widget (créé mais pas attaché)
                window.sketchWidget = null;
                window.sketchConfig = null;
                
                // Charger la configuration et créer le widget Sketch automatiquement
                loadDrawingToolsConfig().then(config => {
                    
                    // Stocker la configuration pour utilisation ultérieure
                    window.sketchConfig = config;
                    
                    // En lecture seule, ne pas créer/ajouter le widget Sketch
                    if (!window.isReadOnlyMode) {
                        // CRÉER AUTOMATIQUEMENT LE WIDGET SKETCH AVEC LA CONFIGURATION
                        createAndActivateSketchWidget();
                    } else {
                    }
                    
                }).catch(error => {
                    console.error('❌ Erreur lors du chargement de la configuration:', error);
                    
                    // Configuration par défaut en cas d'erreur
                    window.sketchConfig = {
                        pointTool: true,
                        polylineTool: true,
                        polygonTool: true,
                        rectangleTool: true,
                        circleTool: true,
                        lassoSelection: false,
                        rectangleSelection: false
                    };
                });

                // Fonction pour charger la configuration des outils depuis Custom Settings List
                function loadDrawingToolsConfig() {
                    return new Promise((resolve, reject) => {
                        try {
                            
                            // Utiliser Remote Objects pour récupérer la configuration
                            const toolSettings = new SObjectModel.ArcGIS_Tool_Settings__c();
                            
                            toolSettings.retrieve({}, function(error, records) {
                                if (error) {
                                    console.error('❌ Erreur lors de la récupération des Custom Settings:', error);
                                    
                                    // Configuration par défaut en cas d'erreur
                                    const defaultConfig = {
                                        pointTool: false,
                                        polylineTool: false,
                                        polygonTool: false,
                                        rectangleTool: true,        // DÉFAUT: activé
                                        circleTool: true,           // DÉFAUT: activé
                                        lassoSelection: false,
                                        rectangleSelection: false
                                    };
                                    
                                    console.log('⚠️ Utilisation de la configuration par défaut:', defaultConfig);
                                    resolve(defaultConfig);
                                } else {
                                    
                                    // Mapper les enregistrements vers la configuration
                                    const config = {
                                        pointTool: false,
                                        polylineTool: false,
                                        polygonTool: false,
                                        rectangleTool: false,
                                        circleTool: false,
                                        lassoSelection: false,
                                        rectangleSelection: false
                                    };
                                    
                                    records.forEach(record => {
                                        const toolType = record.get('Tool_Type__c');
                                        const isEnabled = record.get('Is_Enabled__c');
                                        
                                        console.log(`🔧 Outil: ${record.get('Name')} (${toolType}) = ${isEnabled}`);
                                        
                                        switch(toolType) {
                                            case 'point':
                                                config.pointTool = isEnabled;
                                                break;
                                            case 'polyline':
                                                config.polylineTool = isEnabled;
                                                break;
                                            case 'polygon':
                                                config.polygonTool = isEnabled;
                                                break;
                                            case 'rectangle':
                                                config.rectangleTool = isEnabled;
                                                break;
                                            case 'circle':
                                                config.circleTool = isEnabled;
                                                break;
                                            case 'lasso-selection':
                                                config.lassoSelection = isEnabled;
                                                break;
                                            case 'rectangle-selection':
                                                config.rectangleSelection = isEnabled;
                                                break;
                                        }
                                    });
                                    
                                    resolve(config);
                                }
                            });
                        
                    } catch (error) {
                            console.error('❌ Erreur lors du chargement de la configuration:', error);
                            
                            // Configuration par défaut en cas d'erreur
                            resolve({
                                pointTool: false,
                                polylineTool: false,
                                polygonTool: false,
                                rectangleTool: true,        // DÉFAUT: activé
                                circleTool: true,           // DÉFAUT: activé
                                lassoSelection: false,
                                rectangleSelection: false
                            });
                        }
                    });
                }
                

                
                // Fonction pour créer et activer le widget Sketch à la demande
                function createAndActivateSketchWidget() {
                    
                    if (window.sketchWidget) {
                        console.log('⚠️ Widget Sketch déjà créé');
                        return window.sketchWidget;
                    }
                    
                    if (!window.sketchConfig) {
                        console.error('❌ Configuration non disponible');
                        return null;
                    }
                    
                    
                    // Créer le widget avec la configuration stockée
                const sketchWidget = new Sketch({
                            view: view,
                            layer: sketchLayer,
                        creationMode: "hybrid",
                        defaultUpdateOptions: { 
                            enableRotation: false,
                            enableScaling: false,
                            preserveAspectRatio: true
                        },
                    label: "Outils de dessin ArcGIS",
                    visibleElements: {
                        createTools: {
                                point: window.sketchConfig.pointTool,
                                polyline: window.sketchConfig.polylineTool,
                                polygon: window.sketchConfig.polygonTool,
                                rectangle: window.sketchConfig.rectangleTool,
                                circle: window.sketchConfig.circleTool
                        },
                        selectionTools: {
                                "lasso-selection": window.sketchConfig.lassoSelection,
                                "rectangle-selection": window.sketchConfig.rectangleSelection
                        },
                        undoRedoMenu: true,
                        settingsMenu: true
                    }
                });

                    // Stocker globalement
                    window.sketchWidget = sketchWidget;
                    
                    // Suivre l'état d'activation d'un outil de création
                    window.isSketchCreateMode = false;
                    reactiveUtils.watch(() => sketchWidget.activeTool, function(newTool){
                        window.isSketchCreateMode = !!newTool;
                        if (view && view.popup) {
                            if (window.isSketchCreateMode) {
                                // Fermer et désactiver l'auto-ouverture du popup pour ne pas gêner le dessin
                                if (typeof view.popup.close === 'function') {
                                    view.popup.close();
                                } else {
                                    view.popup.visible = false;
                                }
                                view.popup.autoOpenEnabled = false;
                            } else {
                                view.popup.autoOpenEnabled = true;
                            }
                        }
                    });
                    
                    // AJOUTER LE WIDGET À LA VUE (c'est ce qui manquait !)
                    view.ui.add(sketchWidget, "bottom-right");
                    
                    // Initialiser le widget
                    initializeSketchWidget(sketchWidget);
                    
                    return sketchWidget;
                }
                
                // Fonction pour désactiver et détruire le widget Sketch
                function deactivateSketchWidget() {
                    
                    if (window.sketchWidget) {
                        // Annuler toute opération en cours
                        window.sketchWidget.cancel();
                        
                        // Détruire le widget
                        window.sketchWidget.destroy();
                        window.sketchWidget = null;
                        
                    }
                }
                
                // Fonction pour initialiser le widget Sketch (appelée après création)
                function initializeSketchWidget(sketchWidget) {
                // Attendre que le widget soit initialisé
                sketchWidget.when(() => {
                        
                        // ÉTAT INITIAL: FORCÉ EN MODE INACTIF POUR GÉOCODAGE
                        // Annuler tous les outils actifs et désactiver le widget par défaut
                        sketchWidget.cancel(); // Annule tout outil de création actif
                        // sketchWidget.viewModel.state = "ready"; // Force l'état ready (retiré car non assignable)
                        
                        
                        // Configurer les styles de highlight
                        setupHighlightStyles();
                    
                    // Écouter la création de formes
                        sketchWidget.on("create", function(event) {
                            if (event.state === "complete") {
                            handleShapeCreated(event.graphic, event.tool);
                        }
                    });
                    
                    // Écouter la sélection de formes
                    sketchWidget.on("select", function(event) {
                        if (event.graphics && event.graphics.length > 0) {
                            handleShapeCreated(event.graphics[0]);
                        }
                    });
                    
                    // Écouter la désélection de formes
                        sketchWidget.on("update", function(event) {
                        console.log('🔄 Forme mise à jour:', event);
                        if (event.state === "complete" && event.graphics && event.graphics.length > 0) {
                            handleShapeCreated(event.graphics[0], undefined);
                        }
                    });
                    
                    // Écouter la suppression de formes
                        sketchWidget.on("delete", function(event) {
                        handleShapeDeletion();
                    });
                    
                    // Écouter les changements d'état pour activer le bouton Save
                    sketchWidget.viewModel.on("create", function(event) {
                        if (event.state === "complete") {
                            handleShapeCreated(event.graphic);
                        }
                    });
                        
                        // IMPORTANT: Préserver le géocodage sur clic de carte
                        // Écouter les changements d'outil pour maintenir le géocodage actif
                        reactiveUtils.watch(() => sketchWidget.viewModel.state, function(newState) {
                            
                            // Si aucun outil de création n'est actif, le géocodage reste disponible
                            if (newState === "ready" || newState === "disabled") {
                                // La carte peut recevoir les clics pour le géocodage
                            }
                    });
                });
                    
                    // Rendre le sketchWidget disponible globalement pour les autres fonctions
                    window.sketchWidget = sketchWidget;
                    
                    // Vérifier s'il y a des formes existantes pour activer le bouton Save
                    setTimeout(() => {
                        activateSaveButtonIfShapesExist();
                    }, 1000);
                }
                
                // Fonction pour gérer la création d'une forme
                function handleShapeCreated(graphic, tool) {
                    
                    // Notifier le LWC qu'une forme est disponible
                    if (window.parent) {
                        window.parent.postMessage({
                            type: 'SHAPE_SELECTED',
                            shape: extractShapeInfo(graphic, tool)
                        }, '*');
                    }
                    
                    // Activer le bouton Save si des formes sont présentes
                    activateSaveButtonIfShapesExist();
                }
                
                // Fonction pour gérer la sélection de formes
                function handleShapeSelection() {
                    const selectedGraphics = sketchWidget.view.graphics.filter(g => g.selected);
                    
                    if (selectedGraphics.length > 0) {
                        // Notifier le LWC qu'une forme est sélectionnée
                        if (window.parent) {
                            window.parent.postMessage({
                                type: 'SHAPE_SELECTED',
                                shape: extractShapeInfo(selectedGraphics[0])
                            }, '*');
                        }
                    } else {
                        // Notifier le LWC qu'aucune forme n'est sélectionnée
                        if (window.parent) {
                            window.parent.postMessage({
                                type: 'NO_SHAPE_SELECTED'
                            }, '*');
                        }
                    }
                }
                
                // Fonction pour gérer la suppression de formes
                function handleShapeDeletion() {
                    const remainingGraphics = sketchWidget.view.graphics.length;
                    
                    if (remainingGraphics === 0) {
                        // Notifier le LWC qu'aucune forme n'est disponible
                        if (window.parent) {
                            window.parent.postMessage({
                                type: 'NO_SHAPE_SELECTED'
                            }, '*');
                        }
                    } else {
                        // Activer le bouton Save si des formes restent
                        activateSaveButtonIfShapesExist();
                    }
                }
                
                // Fonction pour activer le bouton Save si des formes existent
                function activateSaveButtonIfShapesExist() {
                    if (sketchWidget && sketchWidget.view) {
                        const graphics = sketchWidget.view.graphics.filter(g => g.geometry);
                        if (graphics.length > 0) {
                            if (window.parent) {
                                window.parent.postMessage({
                                    type: 'SHAPE_SELECTED',
                                    shape: extractShapeInfo(graphics[0])
                                }, '*');
                            }
                        }
                    }
                }
                

                
                // Fonction pour extraire les informations d'une forme
                function extractShapeInfo(graphic, tool) {
                    if (!graphic) {
                        console.error('❌ Graphic est null ou undefined');
                        throw new Error('Graphic invalide');
                    }
                    
                    if (!graphic.geometry) {
                        console.error('❌ Geometry est null ou undefined dans le graphic:', graphic);
                        throw new Error('Géométrie invalide');
                    }
                    
                    const geometry = graphic.geometry;
                    
                    let shapeInfo = {
                        type: 'unknown',
                        coordinates: [],
                        center: null,
                        isCircle: false, // Flag pour préserver le type métier Circle
                        address: null // Adresse obtenue par géocodage
                    };
                    
                    // Récupérer l'adresse si disponible
                    if (graphic.attributes && graphic.attributes.address) {
                        const address = graphic.attributes.address;
                        if (address && address !== "Géocodage en cours..." && 
                            address !== "Adresse non trouvée" && 
                            address !== "Erreur de géocodage") {
                            shapeInfo.address = address;
                        }
                    }
                    
                    // Convertir la géométrie en WGS84 si nécessaire
                    const wgs84Geometry = convertToWGS84(geometry);
                    
                    if (wgs84Geometry.type === 'point') {
                        shapeInfo.type = 'Point';
                        shapeInfo.coordinates = [{
                            latitude: wgs84Geometry.latitude,
                            longitude: wgs84Geometry.longitude
                        }];
                        shapeInfo.center = {
                            latitude: wgs84Geometry.latitude,
                            longitude: wgs84Geometry.longitude
                        };
                    } else if (wgs84Geometry.type === 'polyline') {
                        shapeInfo.type = 'Polyline';
                        shapeInfo.coordinates = wgs84Geometry.paths[0].map(coord => ({
                            latitude: coord[1],
                            longitude: coord[0]
                        }));
                        shapeInfo.center = wgs84Geometry.extent.center;
                    } else if (wgs84Geometry.type === 'polygon') {
                        // Vérifier si c'est un cercle (créé avec l'outil circle)
                        const isCircle = isPolygonACircle(wgs84Geometry);
                        shapeInfo.type = isCircle ? 'Circle' : 'Polygon';
                        shapeInfo.isCircle = isCircle;
                        
                        shapeInfo.coordinates = wgs84Geometry.rings[0].map(coord => ({
                            latitude: coord[1],
                            longitude: coord[0]
                        }));
                        shapeInfo.center = wgs84Geometry.extent.center;
                    } else if (wgs84Geometry.type === 'extent') {
                        // Rectangle ou cercle
                        if (wgs84Geometry.width === wgs84Geometry.height) {
                            shapeInfo.type = 'Circle';
                            shapeInfo.isCircle = true;
                        } else {
                            shapeInfo.type = 'Rectangle';
                        }
                        const xmin = wgs84Geometry.xmin;
                        const ymin = wgs84Geometry.ymin;
                        const xmax = wgs84Geometry.xmax;
                        const ymax = wgs84Geometry.ymax;
                        shapeInfo.coordinates = [
                            { latitude: ymin, longitude: xmin },
                            { latitude: ymin, longitude: xmax },
                            { latitude: ymax, longitude: xmax },
                            { latitude: ymax, longitude: xmin },
                            { latitude: ymin, longitude: xmin }
                        ];
                        shapeInfo.center = wgs84Geometry.center;
                    }
                    
                    // Si l'outil est connu, forcer le type attendu plateforme
                    if (tool) {
                        const toolMap = { point: 'Point', polyline: 'Polyline', polygon: 'Polygon', rectangle: 'Rectangle', circle: 'Circle' };
                        const mapped = toolMap[tool];
                        if (mapped) {
                            shapeInfo.type = mapped;
                            if (mapped === 'Circle') {
                                shapeInfo.isCircle = true;
                            }
                        }
                    }
                    
                    return shapeInfo;
                }
                
                // Fonction pour convertir une géométrie en WGS84
                function convertToWGS84(geometry) {
                    // Vérifier si la géométrie est déjà en WGS84
                    if (geometry.spatialReference && geometry.spatialReference.wkid === 4326) {
                        return geometry;
                    }
                    
                    try {
                        // Gérer le cas WebMercator standard (102100/3857)
                        const wkid = geometry.spatialReference && geometry.spatialReference.wkid;
                        if (wkid === 102100 || wkid === 3857) {
                            const converted = webMercatorUtils.webMercatorToGeographic(geometry);
                            if (converted) {
                                return converted;
                            }
                        }
                        
                        // Si non convertible, retourner tel quel
                        console.warn('⚠️ Conversion WGS84 non appliquée, WKID:', wkid);
                        return geometry;
                    } catch (e) {
                        console.error('❌ Erreur conversion WGS84:', e);
                        return geometry; // Fallback sans conversion
                    }
                }
                
                // Fonction pour détecter si un polygone est un cercle
                function isPolygonACircle(geometry) {
                    if (geometry.type !== 'polygon' || !geometry.rings || geometry.rings.length === 0) {
                                    return false;
                                }
                                
                    const ring = geometry.rings[0];
                    if (ring.length < 4) return false;
                    
                    // Vérifier si c'est approximativement circulaire
                    // Un cercle a des angles réguliers et une forme relativement symétrique
                    const center = geometry.extent.center;
                    const distances = ring.map(coord => {
                        const dx = coord[0] - center.longitude;
                        const dy = coord[1] - center.latitude;
                        return Math.sqrt(dx * dx + dy * dy);
                    });
                    
                    // Calculer la variance des distances (plus elle est faible, plus c'est circulaire)
                    const avgDistance = distances.reduce((sum, d) => sum + d, 0) / distances.length;
                    const variance = distances.reduce((sum, d) => sum + Math.pow(d - avgDistance, 2), 0) / distances.length;
                    const coefficientOfVariation = Math.sqrt(variance) / avgDistance;
                    
                    // Si le coefficient de variation est faible, c'est probablement un cercle
                    return coefficientOfVariation < 0.1; // Seuil ajustable
                }
                
                // Fonction pour s'assurer que les coordonnées sont en WGS84
                function ensureWGS84Coordinates(shapeInfo) {
                    // Vérifier si les coordonnées sont dans les bornes WGS84
                    const isValidWGS84 = (lat, lon) => lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180;
                    
                    // Vérifier le centre
                    if (shapeInfo.center && !isValidWGS84(shapeInfo.center.latitude, shapeInfo.center.longitude)) {
                        console.warn('⚠️ Coordonnées du centre hors bornes WGS84:', shapeInfo.center);
                    }
                    
                    // Vérifier toutes les coordonnées
                    if (shapeInfo.coordinates) {
                        shapeInfo.coordinates.forEach((coord, index) => {
                            if (!isValidWGS84(coord.latitude, coord.longitude)) {
                                console.warn(`⚠️ Coordonnée ${index} hors bornes WGS84:`, coord);
                            }
                        });
                    }
                    
                    return shapeInfo;
                }

                // Gestion détaillée des erreurs de géolocalisation
                locateWidget.on("locate-error", function(event) {
                    console.error('🚨 ERREUR GÉOLOCALISATION DÉTAILLÉE:', {
                        error: event.error,
                        code: event.error.code,
                        message: event.error.message,
                        timestamp: new Date().toISOString(),
                        userAgent: navigator.userAgent,
                        isSecureContext: window.isSecureContext,
                        protocol: window.location.protocol,
                        hostname: window.location.hostname
                    });
                    
                    if (event.error.code === 1) {
                        console.error('❌ Permission de géolocalisation refusée par l\'utilisateur');
                        console.warn('💡 Solution: Vérifier les permissions du navigateur');
                        console.warn('   - Chrome/Edge: Clic sur l\'icône cadenas > Géolocalisation > Autoriser');
                        console.warn('   - Firefox: Outils > Options > Vie privée > Permissions > Géolocalisation');
                        console.warn('   - Safari: Réglages > Confidentialité > Services de localisation');
                        
                        // ✅ TENTATIVE DE RÉINITIALISATION DES PERMISSIONS
                        // Suggérer à l'utilisateur de recharger la page après avoir changé les permissions
                        console.warn('⚠️ Après avoir autorisé, veuillez recharger la page');
                    } else if (event.error.code === 2) {
                        console.error('❌ Position indisponible (GPS désactivé ou signal faible)');
                        console.warn('💡 Solution: Vérifier que le GPS est activé sur votre appareil');
                        console.warn('   - Desktop: Impossible d\'obtenir la position sans GPS/réseau');
                        console.warn('   - Mobile: Activer le GPS ou utiliser le WiFi');
                    } else if (event.error.code === 3) {
                        console.error('⏰ Timeout de géolocalisation (délai dépassé)');
                        console.warn('💡 Solution: Réessayer dans quelques secondes');
                        console.warn('   - Vérifier la connexion réseau');
                        console.warn('   - Vérifier que le GPS a un signal');
                    } else {
                        console.error('❓ Erreur de géolocalisation inconnue:', event.error.message);
                    }
                    
                    // ✅ Test direct de l'API géolocalisation pour diagnostic
                    console.warn('🔍 TEST DIAGNOSTIC DE NAVIGATOR.GEOLOCATION:');
                    if (navigator.geolocation) {
                        navigator.geolocation.getCurrentPosition(
                            function(position) {
                                console.log('✅ Navigator.geolocation fonctionne:', {
                                    latitude: position.coords.latitude,
                                    longitude: position.coords.longitude,
                                    accuracy: position.coords.accuracy
                                });
                            },
                            function(error) {
                                console.error('❌ Test direct échoué avec code:', error.code, 'Message:', error.message);
                            },
                            { timeout: 5000 }
                        );
                    } else {
                        console.error('❌ navigator.geolocation non disponible dans ce navigateur');
                    }
                });

                // Gérer le succès de géolocalisation
                locateWidget.on("locate", function(event) {
                    console.log('✅ Géolocalisation réussie:', {
                        latitude: event.position.coords.latitude,
                        longitude: event.position.coords.longitude,
                        accuracy: event.position.coords.accuracy + ' mètres'
                    });
                });

                // Ajouter les widgets SEULEMENT si mode édition (pas lecture seule)
                if (!window.isReadOnlyMode) {
                    // Ajouter les widgets à la vue selon les conventions ArcGIS
                    // Search reste en haut à gauche
                    view.ui.add(searchWidget, { position: "top-left", index: 0 });
                    // Déplacer Zoom et Locate en bas à gauche (Zoom au-dessus)
                    try { view.ui.move("zoom", { position: "bottom-left", index: 0 }); } catch (e) { try { view.ui.move("zoom", "bottom-left"); } catch (ignore) {} }
                    // Ajouter le widget Locate UNE SEULE FOIS
                    view.ui.add(locateWidget, { position: "bottom-left", index: 1 });
                    view.ui.add(compassWidget, "top-right");   // Compass (navigation)
                    view.ui.add(basemapToggleWidget, "top-right"); // BasemapToggle (changement de fond)
                    // Note: sketchWidget sera ajouté automatiquement dans createAndActivateSketchWidget()
                } else {
                    // En lecture seule, s'assurer que le contrôleur Zoom est visible en bas à droite
                    try { view.ui.move("zoom", "bottom-right"); } catch (e) {}
                }
                // Zoom reste en "bottom-right" par défaut (coexiste avec Sketch)

                console.log('  - Search: top-left (recherche)');
                console.log('  - Compass: top-right (navigation)');
                console.log('  - BasemapToggle: top-right (changement de fond)');
                console.log('  - Locate: bottom-left (géolocalisation)');
                console.log('  - Sketch: bottom-right (outils de dessin)');
                console.log('  - Zoom: bottom-right (par défaut, coexiste avec Sketch)');
                console.log('');
                console.log('  - PC: Shift + glisser pour tourner la carte');
                console.log('  - Mobile: Rotation avec deux doigts');
                console.log('  - Compass: Clic pour remettre au nord');

                // Écouter la sélection d'une suggestion de recherche
                searchWidget.on("select-result", function(event) {
                    
                    if (event.result) {
                        const result = event.result;
                        const location = result.extent || result.feature.geometry;
                        
                        if (location) {
                            // Centrer la carte sur le résultat
                            if (location.extent) {
                                view.goTo(location.extent, { duration: 1000 });
                            } else {
                                view.goTo(location, { duration: 1000 });
                            }
                            
                            // Créer un marqueur sur l'emplacement trouvé
                            const point = location.extent ? location.extent.center : location;
                            const symbol = new SimpleMarkerSymbol({
                                color: [0, 122, 194], // Bleu ArcGIS
                                outline: {
                                    color: [255, 255, 255],
                                    width: 2
                                },
                                size: 12
                            });
                            
                            const graphic = new Graphic({
                                geometry: point,
                                symbol: symbol,
                                attributes: {
                                    latitude: point.latitude ? point.latitude.toFixed(6) : "N/A",
                                    longitude: point.longitude ? point.longitude.toFixed(6) : "N/A",
                                    address: result.name || "Adresse trouvée"
                                },
                                popupTemplate: popupTemplate
                            });
                            
                            // Nettoyer les anciens marqueurs et ajouter le nouveau
                            view.graphics.removeAll();
                            view.graphics.add(graphic);
                            
                            // Ouvrir immédiatement le popup avec "Géocodage en cours..."
                            view.openPopup({
                                title: "📍 Adresse",
                                content: `
                                    <div style="padding: 15px; text-align: center;">
                                        <div style="margin-bottom: 15px;">
                                            <img src="https://js.arcgis.com/4.33/esri/themes/base/images/Loading_Indicator.gif" alt="Loading..." width="20" height="20" />
                                        </div>
                                        <p style="font-size: 14px; color: #666; margin: 0;">
                                            Géocodage en cours...
                                        </p>
                                    </div>
                                `,
                                location: point
                            });
                            
                            // Faire le géocodage en arrière-plan comme pour les clics manuels
                            performGeocoding(point.latitude, point.longitude, graphic);
                            
                        }
                    }
                });
                
                // Créer le PopupTemplate pour afficher les informations de géocodage
                const popupTemplate = new PopupTemplate({
                    title: "📍 Informations de localisation",
                    content: [
                        {
                            type: "fields",
                            fieldInfos: [
                                {
                                    fieldName: "address",
                                    label: "Adresse",
                                    visible: true
                                },
                                {
                                    fieldName: "latitude",
                                    label: "Latitude",
                                    visible: true
                                },
                                {
                                    fieldName: "longitude",
                                    label: "Longitude",
                                    visible: true
                                }
                            ]
                        }
                    ]
                });
                
                // Configuration des clics sur graphics intégrée dans le handler principal
                
                view.when(() => {
                    
                    // Notifier le parent (LWC) que la carte est prête
                    if (window.parent) {
                        window.parent.postMessage({
                            type: 'MAP_READY',
                            message: 'ArcGIS map initialized successfully'
                        }, '*');
                    }
                });
                
                // HANDLER DE CLIC - DÉSACTIVÉ EN LECTURE SEULE
                view.on("click", function(event) {
                    if (window.isReadOnlyMode) {
                        return;
                    }
                    
                    // Si un outil de création Sketch est actif, laisser Sketch gérer
                    if (window.isSketchCreateMode) {
                        return;
                    }
                    
                    // Si le popup auto est désactivé (mode dessin), ne pas géocoder
                    if (view && view.popup && view.popup.autoOpenEnabled === false) {
                        console.log('🛑 Popup désactivé pour dessin - clic ignoré');
                        return;
                    }
                    
                    // Si le widget Sketch existe et qu'un outil de création est sélectionné, ne pas interférer
                    if (window.sketchWidget) {
                        const vm = window.sketchWidget.viewModel || {};
                        const activeTool = window.sketchWidget.activeTool || vm.activeTool;
                        const state = vm.state;
                        if (activeTool) {
                        return; // Laisser le widget Sketch gérer le clic
                        }
                        if (state !== "ready" && state !== "disabled") {
                            return;
                        }
                    }
                    
                    
                    const coords = {
                        longitude: event.mapPoint.longitude,
                        latitude: event.mapPoint.latitude
                    };
                    
                    
                    // Envoyer les coordonnées au parent (LWC)
                    if (window.parent) {
                        window.parent.postMessage({
                            type: 'MAP_CLICK',
                            coordinates: coords
                        }, '*');
                    }
                    
                    // Créer un point pour le popup
                    const point = new Point({
                        longitude: event.mapPoint.longitude,
                        latitude: event.mapPoint.latitude
                    });
                    
                    // Créer un marqueur temporaire
                    const symbol = new SimpleMarkerSymbol({
                        color: [226, 119, 40],
                        outline: {
                            color: [255, 255, 255],
                            width: 2
                        }
                    });
                    
                    // Créer le graphic avec le popup
                    const graphic = new Graphic({
                        geometry: point,
                        symbol: symbol,
                        popupTemplate: popupTemplate,
                        attributes: {
                            latitude: coords.latitude.toFixed(6),
                            longitude: coords.longitude.toFixed(6),
                            address: "Géocodage en cours..."
                        }
                    });
                    
                    // Nettoyer les anciens marqueurs et ajouter le nouveau
                    view.graphics.removeAll();
                    view.graphics.add(graphic);
                    
                    // Ouvrir immédiatement le popup avec "Géocodage en cours..."
                    view.openPopup({
                        title: "📍 Adresse",
                        content: `
                            <div style="padding: 15px; text-align: center;">
                                <div style="margin-bottom: 15px;">
                                    <img src="https://js.arcgis.com/4.33/esri/themes/base/images/Loading_Indicator.gif" alt="Loading..." width="20" height="20" />
                                </div>
                                <p style="font-size: 14px; color: #666; margin: 0;">
                                    Géocodage en cours...
                                </p>
                            </div>
                        `,
                        location: point
                    });
                    
                    // Faire le géocodage en arrière-plan
                    performGeocoding(coords.latitude, coords.longitude, graphic);
                    
                }, { passive: false }); // Événement non-passif pour permettre preventDefault si nécessaire
                
                // Fonction de géocodage
                function performGeocoding(latitude, longitude, graphic) {
                    
                    // Appel à l'API ArcGIS Geocoding
                    const geocodeUrl = `https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/reverseGeocode?location=${longitude},${latitude}&outSR=4326&returnIntersection=false&f=json`;
                    
                    fetch(geocodeUrl)
                        .then(response => response.json())
                        .then(data => {
                            
                            if (data.address) {
                                const address = formatAddress(data.address);
                                
                                // Mettre à jour le graphic avec l'adresse
                                graphic.attributes.address = address;
                                
                                
                                // Ouvrir automatiquement le popup avec l'adresse
                                view.openPopup({
                                    title: "📍 Adresse",
                                    content: `
                                        <div style="padding: 20px; text-align: center;">
                                            <div style="font-size: 16px; line-height: 1.4; color: #333;">
                                                ${address}
                                            </div>
                                        </div>
                                    `,
                                    location: graphic.geometry
                                });
                                
                                
                                // NOTIFIER LE LWC QU'UNE ADRESSE EST SÉLECTIONNÉE (comme une forme dessinée)
                                if (window.parent) {
                                    window.parent.postMessage({
                                        type: 'ADDRESS_SELECTED',
                                        address: {
                                            type: 'Adresse',
                                            coordinates: [{
                                                latitude: parseFloat(graphic.attributes.latitude),
                                                longitude: parseFloat(graphic.attributes.longitude)
                                            }],
                                            center: {
                                                latitude: parseFloat(graphic.attributes.latitude),
                                                longitude: parseFloat(graphic.attributes.longitude)
                                            },
                                            address: address,
                                            isAddress: true // Flag pour identifier les adresses
                                        }
                                    }, '*');
                                    
                                    
                                    // ENVOYER AUSSI SHAPE_SELECTED pour activer le bouton Save
                                    window.parent.postMessage({
                                        type: 'SHAPE_SELECTED',
                                        shape: {
                                            type: 'Point',
                                            coordinates: [{
                                                latitude: parseFloat(graphic.attributes.latitude),
                                                longitude: parseFloat(graphic.attributes.longitude)
                                            }],
                                            center: {
                                                latitude: parseFloat(graphic.attributes.latitude),
                                                longitude: parseFloat(graphic.attributes.longitude)
                                            },
                                            address: address,
                                            isAddress: true
                                        }
                                    }, '*');
                                }
                        } else {
                                console.log('⚠️ Aucune adresse trouvée');
                                graphic.attributes.address = "Adresse non trouvée";
                                
                                // NOTIFIER LE LWC QU'UNE ADRESSE EST SÉLECTIONNÉE (même sans adresse)
                                if (window.parent) {
                                    window.parent.postMessage({
                                        type: 'ADDRESS_SELECTED',
                                        address: {
                                            type: 'Adresse',
                                            coordinates: [{
                                                latitude: parseFloat(graphic.attributes.latitude),
                                                longitude: parseFloat(graphic.attributes.longitude)
                                            }],
                                            center: {
                                                latitude: parseFloat(graphic.attributes.latitude),
                                                longitude: parseFloat(graphic.attributes.longitude)
                                            },
                                            address: "Adresse non trouvée",
                                            isAddress: true // Flag pour identifier les adresses
                                        }
                                    }, '*');
                                    
                                    
                                    // ENVOYER AUSSI SHAPE_SELECTED pour activer le bouton Save
                                    window.parent.postMessage({
                                        type: 'SHAPE_SELECTED',
                                        shape: {
                                            type: 'Point',
                                            coordinates: [{
                                                latitude: parseFloat(graphic.attributes.latitude),
                                                longitude: parseFloat(graphic.attributes.longitude)
                                            }],
                                            center: {
                                                latitude: parseFloat(graphic.attributes.latitude),
                                                longitude: parseFloat(graphic.attributes.longitude)
                                            },
                                            address: "Adresse non trouvée",
                                            isAddress: true
                                        }
                                    }, '*');
                                }
                                
                                // Ouvrir popup avec message d'erreur
                                view.openPopup({
                                    title: "📍 Adresse",
                                    content: `
                                        <div style="padding: 20px; text-align: center;">
                                            <div style="font-size: 16px; color: #d73a49; margin-bottom: 10px;">
                                                ⚠️ Adresse non trouvée
                                            </div>
                                            <div style="font-size: 14px; color: #666;">
                                                Impossible de récupérer l'adresse pour ces coordonnées
                                            </div>
                                        </div>
                                    `,
                                    location: graphic.geometry
                                });
                            }
                        })
                        .catch(error => {
                            console.error('❌ Erreur géocodage:', error);
                            graphic.attributes.address = "Erreur de géocodage";
                            
                            // Ouvrir popup avec message d'erreur
                            view.openPopup({
                                title: "📍 Adresse",
                                content: `
                                    <div style="padding: 20px; text-align: center;">
                                        <div style="font-size: 16px; color: #d73a49; margin-bottom: 10px;">
                                            ❌ Erreur de géocodage
                                        </div>
                                        <div style="font-size: 14px; color: #666;">
                                            Impossible de récupérer l'adresse
                                        </div>
                                    </div>
                                `,
                                location: graphic.geometry
                            });
                        });
                }
                
                // Fonction de formatage d'adresse
                function formatAddress(addressData) {
                    const parts = [];
                    
                    if (addressData.Address) parts.push(addressData.Address);
                    if (addressData.City) parts.push(addressData.City);
                    if (addressData.Region) parts.push(addressData.Region);
                    if (addressData.Postal) parts.push(addressData.Postal);
                    if (addressData.CountryCode) parts.push(addressData.CountryCode);
                    
                    return parts.length > 0 ? parts.join(', ') : 'Adresse non disponible';
                }
                
                // Fonction pour sauvegarder une forme
                function handleSaveShape(data) {
                    try {
                        // Récupérer UNIQUEMENT la dernière forme du sketchLayer (éviter les doublons)
                        let graphic = null;
                        
                        if (sketchLayer && sketchLayer.graphics && sketchLayer.graphics.length > 0) {
                            // Prendre la dernière forme créée dans le sketchLayer
                            graphic = sketchLayer.graphics.getItemAt(sketchLayer.graphics.length - 1);
                        } else if (view && view.graphics && view.graphics.length > 0) {
                            // Fallback : prendre la dernière forme de la vue principale (géocodage)
                            graphic = view.graphics.getItemAt(view.graphics.length - 1);
                        }
                        
                        if (!graphic || !graphic.geometry) {
                            console.warn('⚠️ Aucune forme à sauvegarder');
                            notifyParent('SAVE_ERROR', { error: 'Aucune forme à sauvegarder' });
                            return;
                        }
                        
                        const shapeInfo = extractShapeInfo(graphic);
                        
                        // Préparer les données pour l'Apex
                        const mapAreaData = {
                            Area_Type__c: shapeInfo.type,
                            Geometry_JSON__c: JSON.stringify(convertToGeoJSON(shapeInfo)),
                            Latitude__c: shapeInfo.center ? shapeInfo.center.latitude : null,
                            Longitude__c: shapeInfo.center ? shapeInfo.center.longitude : null,
                            Address__c: shapeInfo.address || null
                        };
                        
                        // ✅ PASSER LE CONTEXTE REÇU DU LWC À saveMapAreaRemote
                        // data contient: recordId, relationshipFieldName, champRelation, idParent
                        saveMapAreaRemote(mapAreaData, data);
                        
                    } catch (error) {
                        console.error('❌ Erreur lors de la préparation de sauvegarde:', error);
                        notifyParent('SAVE_ERROR', { error: error.message });
                    }
                }
                
                // Fonction pour effacer la forme courante
                function clearCurrentShape() {
                    if (sketchWidget) {
                        sketchWidget.cancel();
                        const graphics = sketchWidget.view.graphics.filter(g => g.geometry);
                        if (graphics.length > 0) {
                            sketchWidget.view.graphics.remove(graphics[graphics.length - 1]);
                        }
                        notifyParent('NO_SHAPE_SELECTED');
                    }
                }
                
                // Fonction pour effacer toutes les formes
                function clearAllShapes() {
                    if (sketchWidget) {
                        sketchWidget.cancel();
                        // Nettoyer les graphiques de la vue principale
                        if (view && view.graphics) {
                            view.graphics.removeAll();
                        }
                        // Nettoyer le layer de sketch (mais pas savedLayer)
                        sketchLayer.removeAll();
                        // Fermer tout popup ouvert
                        if (view && view.popup) {
                            if (typeof view.popup.close === 'function') { view.popup.close(); } else { view.popup.visible = false; }
                        }
                        
                        notifyParent('NO_SHAPE_SELECTED');
                    }
                    
                    // ✅ NOUVEAU: Envoyer MAP_READY à nouveau après CLEAR_ALL
                    // Cela va déclencher UPDATE_CONTEXT sur le LWC
                    if (window.parent) {
                        window.parent.postMessage({
                            type: 'MAP_READY',
                            message: 'Map cleared, ready for new context'
                        }, '*');
                    }
                }
                
                // generateMapAreaName n'est plus utilisé (Name standard auto)
                
                // Fonction pour convertir en GeoJSON
                function convertToGeoJSON(shapeInfo) {
                    if (shapeInfo.type === 'Point') {
                        return {
                            type: "Feature",
                            geometry: {
                                type: 'Point',
                                coordinates: [shapeInfo.coordinates[0].longitude, shapeInfo.coordinates[0].latitude]
                            },
                            properties: {
                                originalType: shapeInfo.type,
                                address: shapeInfo.address,
                                isCircle: shapeInfo.isCircle || false
                            }
                        };
                    } else if (shapeInfo.type === 'Polyline') {
                        return {
                            type: "Feature",
                            geometry: {
                                type: 'LineString',
                                coordinates: shapeInfo.coordinates.map(c => [c.longitude, c.latitude])
                            },
                            properties: {
                                originalType: shapeInfo.type,
                                address: shapeInfo.address,
                                isCircle: false
                            }
                        };
                    } else {
                        // Polygon / Rectangle (anneau unique)
                        return {
                            type: "Feature",
                            geometry: {
                                type: 'Polygon',
                                coordinates: [shapeInfo.coordinates.map(c => [c.longitude, c.latitude])]
                            },
                            properties: {
                                originalType: shapeInfo.type,
                                address: shapeInfo.address,
                                isCircle: shapeInfo.isCircle || false
                            }
                        };
                    }
                }
                
                // Fonction pour notifier le parent LWC
                function notifyParent(type, data = {}) {
                    if (window.parent) {
                        window.parent.postMessage({ type, data }, '*');
                    }
                }
                
                // Fonction Apex Remoting pour sauvegarder
                function saveMapAreaRemote(mapAreaData, contextData) {

                    try {
                        // Construire le payload ShapeData attendu par l'Apex LWC
                        const shapeData = {
                            areaType: mapAreaData.Area_Type__c,
                            geoJson: mapAreaData.Geometry_JSON__c,
                            latitude: mapAreaData.Latitude__c,
                            longitude: mapAreaData.Longitude__c,
                            address: mapAreaData.Address__c
                        };

                        
                        // ✅ UTILISER LE CONTEXTE REÇU DU LWC AU LIEU DE window.lwcContext
                        // contextData contient: recordId, relationshipFieldName, champRelation, idParent
                        const recordId = contextData && contextData.recordId ? contextData.recordId : null;
                        const relationshipFieldName = contextData && contextData.relationshipFieldName ? contextData.relationshipFieldName : null;

                        // Notifier le parent (LWC) pour qu'il appelle l'Apex
                        if (window.parent) {
                            window.parent.postMessage({
                                type: 'SHAPE_DATA',
                                data: { 
                                    shapeData,
                                    recordId,
                                    relationshipFieldName
                                }
                            }, '*');
                        }
                    } catch (error) {
                        console.error('❌ Erreur lors de la préparation des données de sauvegarde:', error);
                        notifyParent('SAVE_ERROR', { error: error.message || 'Erreur de préparation des données' });
                    }
                }
                
                // Écouter les messages du parent (LWC)
                // ✅ IMPORTANT: Fonction nommée + détachement précédent pour éviter doublons
                window.removeEventListener('message', window.__vfMessageHandler);
                window.__vfMessageHandler = function(event) {
                    
                    if (event.data.type === 'CENTER_MAP') {
                        view.center = [event.data.longitude, event.data.latitude];
                        if (event.data.zoom) {
                            view.zoom = event.data.zoom;
                        }
                    } else if (event.data.type === 'DISPLAY_SAVED_SHAPE') {
                        displaySavedShape(event.data);
                    } else if (event.data.type === 'SAVE_SHAPE') {
                        console.log('💾 Demande de sauvegarde reçue');
                        handleSaveShape(event.data.data);
                    } else if (event.data.type === 'CLEAR_SHAPE') {
                        console.log('🧹 Demande d\'effacement de forme');
                        clearCurrentShape();
                    } else if (event.data.type === 'CLEAR_ALL') {
                        console.log('🧹 Demande d\'effacement total');
                        clearAllShapes();
                    } else if (event.data.type === 'GEOCODE_REQUEST') {
                        
                        // Créer un point pour le popup
                        const point = new Point({
                            longitude: event.data.coordinates.longitude,
                            latitude: event.data.coordinates.latitude
                        });
                        
                        // Créer le graphic avec le popup
                        const graphic = new Graphic({
                            geometry: point,
                            symbol: new SimpleMarkerSymbol({
                                color: [226, 119, 40],
                                outline: { color: [255, 255, 255], width: 2 }
                            }),
                            popupTemplate: popupTemplate,
                            attributes: {
                                latitude: event.data.coordinates.latitude.toFixed(6),
                                longitude: event.data.coordinates.longitude.toFixed(6),
                                address: "Géocodage en cours..."
                            }
                        });
                        
                        // Nettoyer et ajouter le nouveau marqueur
                        view.graphics.removeAll();
                        view.graphics.add(graphic);
                        
                        // Ouvrir immédiatement le popup avec "Géocodage en cours..."
                        view.openPopup({
                            title: "📍 Adresse",
                            content: `
                                <div style="padding: 15px; text-align: center;">
                                    <div style="margin-bottom: 15px;">
                                        <img src="https://js.arcgis.com/4.33/esri/themes/base/images/Loading_Indicator.gif" alt="Loading..." width="20" height="20" />
                                    </div>
                                    <p style="font-size: 20px; color: #666; margin: 0;">
                                        Géocodage en cours...
                                    </p>
                                </div>
                            `,
                            location: point
                        });
                        
                        // Faire le géocodage
                        performGeocoding(event.data.coordinates.latitude, event.data.coordinates.longitude, graphic);
                        
                    } else if (event.data.type === 'GET_CURRENT_SHAPE') {
                        
                        // Récupérer toutes les formes du sketchLayer
                        const allGraphics = sketchLayer.graphics.toArray();
                        
                        if (allGraphics.length > 0) {
                            // Extraire les informations de toutes les formes
                            const shapes = allGraphics.map(graphic => extractShapeInfo(graphic));
                            
                            // Envoyer la réponse au LWC
                            if (window.parent) {
                                window.parent.postMessage({
                                    type: 'CURRENT_SHAPES_RESPONSE',
                                    shapes: shapes,
                                    totalCount: shapes.length
                                }, '*');
                            }
                            
                        } else {
                            // Aucune forme disponible
                            if (window.parent) {
                                window.parent.postMessage({
                                    type: 'CURRENT_SHAPES_RESPONSE',
                                    shapes: [],
                                    totalCount: 0
                                }, '*');
                            }
                            
                        }
                    } else if (event.data.type === 'CLEAR_SELECTION') {
                        
                        // Désélectionner toutes les formes
                        if (sketchWidget && sketchWidget.view) {
                            sketchWidget.view.graphics.forEach(graphic => {
                                graphic.selected = false;
                            });
                        }
                        
                        // Notifier le LWC que la sélection est vide
                        if (window.parent) {
                            window.parent.postMessage({
                                type: 'NO_SHAPE_SELECTED'
                            }, '*');
                        }
                        
                    } else if (event.data.type === 'ACTIVATE_DRAWING_MODE') {
                        
                        // Créer et activer le widget Sketch
                        createAndActivateSketchWidget();
                        
                    } else if (event.data.type === 'DEACTIVATE_DRAWING_MODE') {
                        
                        // Désactiver le widget Sketch et revenir au mode natif
                        deactivateSketchWidget();
                        
                    } else if (event.data.type === 'SET_DRAWING_MODE') {
                        
                        // S'assurer que le widget existe
                        if (!window.sketchWidget) {
                            createAndActivateSketchWidget();
                        }
                        
                        // Activer l'outil spécifique
                        if (window.sketchWidget) {
                            setDrawingMode(event.data.tool);
                        }
                        
                    } else if (event.data.type === 'UNDO_LAST_SHAPE') {
                        console.log('↶ Annulation de la dernière forme');
                        undoLastShape();
                    } else if (event.data.type === 'UPDATE_CONTEXT') {
                        console.log('🔄 UPDATE_CONTEXT reçu:', event.data.data);
                        
                        // ✅ STOCKER LE NOUVEAU CONTEXTE GLOBALEMENT
                        window.lwcContext = {
                            recordId: event.data.data.recordId,
                            relationshipFieldName: event.data.data.relationshipFieldName,
                            readOnly: event.data.data.readOnly
                        };
                        
                    }
                };
                // ✅ ATTACHER le handler nommé
                window.addEventListener('message', window.__vfMessageHandler);
                
                // Fonction pour changer le mode de dessin
                function setDrawingMode(tool) {
                    if (!window.sketchWidget) {
                        console.warn('⚠️ SketchWidget pas encore initialisé');
                        return;
                    }
                    
                    try {
                        // Désactiver d'abord tous les outils
                        window.sketchWidget.cancel();
                        
                        if (tool === 'select') {
                            // Mode sélection - pas d'outil actif
                            console.log('✋ Mode sélection activé');
                        } else {
                            // Activer l'outil demandé
                            const toolMapping = {
                                'point': 'point',
                                'polyline': 'polyline', 
                                'polygon': 'polygon',
                                'rectangle': 'rectangle',
                                'circle': 'circle'
                            };
                            
                            const sketchTool = toolMapping[tool];
                            if (sketchTool) {
                                // VÉRIFIER QUE L'OUTIL EST AUTORISÉ DANS LA CONFIGURATION
                                if (window.sketchConfig && window.sketchConfig[sketchTool + 'Tool']) {
                                    window.sketchWidget.create(sketchTool);
                                } else {
                                    console.warn('⚠️ Outil non autorisé dans la configuration:', sketchTool);
                                    // Revenir au mode sélection
                                    window.sketchWidget.cancel();
                                }
                            } else {
                                console.warn('⚠️ Outil non reconnu:', tool);
                            }
                        }
                        
                        // Mettre à jour le compteur
                        updateShapeCount();
                        
                    } catch (error) {
                        console.error('❌ Erreur lors du changement d\'outil:', error);
                    }
                }
                
                // Fonction pour mettre à jour dynamiquement la configuration des outils
                function updateDrawingToolsConfig() {
                    console.log('🔄 Mise à jour dynamique de la configuration des outils...');
                    
                    // Recharger la configuration depuis Custom Settings
                    loadDrawingToolsConfig().then(newConfig => {
                        
                        // Mettre à jour la configuration globale
                        window.sketchConfig = newConfig;
                        
                        // Mettre à jour le widget Sketch si il existe
                        if (window.sketchWidget) {
                            
                            // Recréer le widget avec la nouvelle configuration
                            deactivateSketchWidget();
                            createAndActivateSketchWidget();
                        }
                        
                    }).catch(error => {
                        console.error('❌ Erreur lors de la mise à jour de la configuration:', error);
                    });
                }
                
                // Fonction pour annuler la dernière forme
                function undoLastShape() {
                    if (!sketchLayer) {
                        console.warn('⚠️ SketchLayer pas encore initialisé');
                        return;
                    }
                    
                    try {
                        const graphics = sketchLayer.graphics;
                        if (graphics.length > 0) {
                            // Supprimer la dernière forme ajoutée
                            const lastGraphic = graphics.getItemAt(graphics.length - 1);
                            sketchLayer.remove(lastGraphic);
                            
                            // Mettre à jour le compteur
                            updateShapeCount();
                        } else {
                            console.log('ℹ️ Aucune forme à annuler');
                        }
                    } catch (error) {
                        console.error('❌ Erreur lors de l\'annulation:', error);
                    }
                }
                
                // Fonction pour mettre à jour le compteur de formes
                function updateShapeCount() {
                    if (!sketchLayer) return;
                    
                    const totalCount = sketchLayer.graphics.length;
                    const selectedCount = sketchLayer.graphics.filter(g => g.selected).length;
                    
                    // Envoyer la mise à jour au LWC
                    if (window.parent) {
                        window.parent.postMessage({
                            type: 'SHAPE_COUNT_UPDATE',
                            totalCount: totalCount,
                            selectedCount: selectedCount
                        }, '*');
                    }
                    
                    console.log(`📊 Compteur mis à jour: ${totalCount} formes, ${selectedCount} sélectionnées`);
                }
                
                // Fonction pour configurer les styles de highlight
                function setupHighlightStyles() {
                    // Configurer les styles des formes sélectionnées
                    if (sketchWidget && sketchWidget.viewModel) {
                        // Style pour les formes sélectionnées
                        const selectedStyle = {
                            color: [255, 165, 0, 0.8], // Orange avec transparence
                            outline: {
                                color: [255, 100, 0, 1], // Orange foncé pour le contour
                                width: 3
                            }
                        };
                        
                        // Style pour les formes non sélectionnées
                        const normalStyle = {
                            color: [0, 122, 194, 0.6], // Bleu ArcGIS avec transparence
                            outline: {
                                color: [0, 122, 194, 1], // Bleu ArcGIS pour le contour
                                width: 2
                            }
                        };
                        
                        
                        // Écouter les changements de sélection pour appliquer les styles
                        sketchWidget.on("select", function(event) {
                            applyHighlightStyles();
                        });
                        
                        sketchWidget.on("update", function(event) {
                            if (event.state === "complete") {
                                applyHighlightStyles();
                            }
                        });
                    }
                }
                
                // Fonction pour appliquer les styles de highlight
                function applyHighlightStyles() {
                    if (!sketchLayer) return;
                    
                    sketchLayer.graphics.forEach(graphic => {
                        if (graphic.selected) {
                            // Style pour les formes sélectionnées (orange)
                            if (graphic.geometry.type === 'point') {
                                graphic.symbol = {
                                    type: "simple-marker",
                                    color: [255, 165, 0, 0.8],
                                    outline: {
                                        color: [255, 100, 0, 1],
                                        width: 3
                                    },
                                    size: 12
                                };
                            } else {
                                graphic.symbol = {
                                    type: graphic.geometry.type === 'polyline' ? "simple-line" : "simple-fill",
                                    color: [255, 165, 0, 0.3],
                                    outline: {
                                        color: [255, 100, 0, 1],
                                        width: 3
                                    }
                                };
                            }
                        } else {
                            // Style pour les formes normales (bleu)
                            if (graphic.geometry.type === 'point') {
                                graphic.symbol = {
                                    type: "simple-marker",
                                    color: [0, 122, 194, 0.8],
                                    outline: {
                                        color: [0, 122, 194, 1],
                                        width: 2
                                    },
                                    size: 10
                                };
                            } else {
                                graphic.symbol = {
                                    type: graphic.geometry.type === 'polyline' ? "simple-line" : "simple-fill",
                                    color: [0, 122, 194, 0.2],
                                    outline: {
                                        color: [0, 122, 194, 1],
                                        width: 2
                                    }
                                };
                            }
                        }
                    });
                    
                }

                // Afficher une forme sauvegardée dans le layer dédié et la mettre en évidence
                function displaySavedShape(data) {
                    try {
                        const geometryData = data.geometryData; // GeoJSON string
                        const feature = typeof geometryData === 'string' ? JSON.parse(geometryData) : geometryData;
                        const areaType = data.areaType;
                        
                        // Créer le graphic selon type
                        let graphic = null;
                        switch (areaType) {
                            case 'Point':
                                graphic = createReadOnlyPointGraphic(feature);
                                break;
                            case 'Polyline':
                                graphic = createReadOnlyPolylineGraphic(feature);
                                break;
                            case 'Polygon':
                            case 'Rectangle':
                            case 'Circle':
                                graphic = createReadOnlyPolygonGraphic(feature);
                                break;
                        }
                        if (!graphic) return;
                        
                        // Option: style de mise en évidence
                        if (graphic.symbol && graphic.symbol.outline) {
                            graphic.symbol.outline.width = 3;
                        }
                        
                        // Ajouter/mettre en avant
                        savedLayer.add(graphic);
                        
                        // Centrer la vue
                        if (data.autoCenter) {
                            const extent = graphic.geometry.extent || graphic.geometry;
                            view.goTo({ target: extent, zoom: extent.type === 'point' ? 16 : undefined });
                        }
                    } catch (e) {
                        console.error('❌ Erreur displaySavedShape:', e);
                    }
                }
            });
            

            
            // Fonction pour afficher une géométrie en mode lecture seule
            function displayReadOnlyGeometry(data) {
                try {
                    // Mettre à jour le mode global
                    window.isReadOnlyMode = data.readOnlyMode || false;
                    
                    const geometryData = data.geometryData;
                    const feature = JSON.parse(geometryData);
                    
                    // Effacer les graphiques existants
                            sketchLayer.removeAll();
                    
                    let graphic = null;
                    
                    // Créer le graphique selon le type de géométrie
                    switch (feature.properties.originalType || feature.properties.shapeType) {
                        case 'Circle':
                            graphic = createReadOnlyCircleGraphic(feature, data.centerCoordinates);
                            break;
                        case 'Point':
                            graphic = createReadOnlyPointGraphic(feature);
                            break;
                        case 'Polygon':
                            graphic = createReadOnlyPolygonGraphic(feature);
                            break;
                        case 'Polyline':
                            graphic = createReadOnlyPolylineGraphic(feature);
                            break;
                        case 'Rectangle':
                            graphic = createReadOnlyRectangleGraphic(feature);
                            break;
                        default:
                            console.warn('⚠️ Type de géométrie non supporté:', feature.properties.originalType);
                    }
                    
                    if (graphic) {
                        // Ajouter à la carte avec style lecture seule
                        sketchLayer.add(graphic);
                        
                        // Centrer la vue si demandé
                        if (data.autoCenter) {
                            const extent = graphic.geometry.extent || graphic.geometry;
                            view.goTo({
                                target: extent,
                                zoom: extent.type === 'point' ? 16 : undefined
                            }).then(() => {
                            });
                        }
                        
                        // Désactiver les outils de dessin en mode lecture seule
                        if (window.sketchWidget) {
                            window.sketchWidget.cancel();
                            window.sketchWidget.view = null; // Désactiver complètement
                        }
                        
                    }
                    
                } catch (error) {
                    console.error('❌ Erreur affichage géométrie lecture seule:', error);
                }
            }
            
            // Fonction pour créer un cercle en lecture seule
            function createReadOnlyCircleGraphic(feature, centerCoordinates) {
                const radius = feature.properties.radius;
                let center;
                
                // Utiliser les coordonnées du centre si disponibles
                if (centerCoordinates && centerCoordinates.latitude && centerCoordinates.longitude) {
                    center = [centerCoordinates.longitude, centerCoordinates.latitude];
                } else if (feature.geometry.coordinates && feature.geometry.coordinates[0] && feature.geometry.coordinates[1]) {
                    center = feature.geometry.coordinates;
                } else {
                    console.warn('⚠️ Coordonnées du centre manquantes pour le cercle');
                    return null;
                }
                
                // Créer le cercle
                const circle = new geometryEngine.geodesicBuffer(
                    new Point({
                        longitude: center[0],
                        latitude: center[1]
                    }),
                    radius,
                    'meters'
                );
                
                return new Graphic({
                    geometry: circle,
                    symbol: {
                        type: "simple-fill",
                        color: [51, 153, 255, 0.3], // Bleu clair transparent
                        outline: {
                            color: [51, 153, 255, 0.8], // Bleu plus foncé
                            width: 2
                        }
                    }
                });
            }
            
            // Fonction pour créer un point en lecture seule
            function createReadOnlyPointGraphic(feature) {
                const coords = feature.geometry.coordinates;
                
                return new Graphic({
                    geometry: new Point({
                        longitude: coords[0],
                        latitude: coords[1]
                    }),
                    symbol: {
                        type: "simple-marker",
                        color: [51, 153, 255, 0.8],
                        outline: {
                            color: [51, 153, 255, 1],
                            width: 2
                        },
                        size: 12
                    }
                });
            }
            
            // Fonction pour créer un polygone en lecture seule
            function createReadOnlyPolygonGraphic(feature) {
                return new Graphic({
                    geometry: {
                        type: "polygon",
                        rings: feature.geometry.coordinates
                    },
                    symbol: {
                        type: "simple-fill",
                        color: [51, 153, 255, 0.3],
                        outline: {
                            color: [51, 153, 255, 0.8],
                            width: 2
                        }
                    }
                });
            }
            
            // Fonction pour créer une polyligne en lecture seule
            function createReadOnlyPolylineGraphic(feature) {
                return new Graphic({
                    geometry: {
                        type: "polyline",
                        paths: feature.geometry.coordinates
                    },
                    symbol: {
                        type: "simple-line",
                        color: [51, 153, 255, 0.8],
                        width: 3
                    }
                });
            }
            
            // Fonction pour créer un rectangle en lecture seule
            function createReadOnlyRectangleGraphic(feature) {
                // Les rectangles sont stockés comme des polygones
                return createReadOnlyPolygonGraphic(feature);
            }
            
        </script>
    </body>
    </html>
</apex:page>
