<apex:page showHeader="false" sidebar="false" standardStylesheets="false" docType="html-5.0">
    <!-- Support Visualforce Remoting -->
    <apex:remoteObjects>
        <apex:remoteObjectModel name="ArcGIS_Tool_Settings__c" fields="Name,Tool_Type__c,Is_Enabled__c" />
    </apex:remoteObjects>
    
    <html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>ArcGIS Map</title>
        
        <!-- ArcGIS Maps SDK 4.33 -->
        <link rel="stylesheet" href="https://js.arcgis.com/4.33/esri/themes/light/main.css" />
        <script src="https://js.arcgis.com/4.33/init.js"></script>
        
        <style>
            html, body, #viewDiv {
                padding: 0;
                margin: 0;
                height: 100%;
                width: 100%;
                font-family: 'Avenir Next', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            }
            
            /* Style pour le widget Search */
            .esri-search {
                width: 300px;
                max-width: 90vw;
            }
            
            .esri-search__input {
                border-radius: 6px;
                border: 2px solid #e1e5e9;
                font-size: 14px;
                padding: 8px 12px;
                transition: border-color 0.2s ease;
            }
            
            .esri-search__input:focus {
                border-color: #0079c1;
                outline: none;
                box-shadow: 0 0 0 3px rgba(0, 121, 193, 0.1);
            }
            
            .esri-search__suggestions {
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                border: 1px solid #e1e5e9;
            }
            
            .esri-search__suggestion {
                padding: 10px 12px;
                border-bottom: 1px solid #f0f0f0;
                cursor: pointer;
                transition: background-color 0.2s ease;
            }
            
            .esri-search__suggestion:hover {
                background-color: #f8f9fa;
            }
            
            .esri-search__suggestion:last-child {
                border-bottom: none;
            }
        </style>
    </head>
    <body>
        <div id="viewDiv"></div>
        
        <script>
            require([
                "esri/Map",
                "esri/views/MapView",
                "esri/geometry/Point",
                "esri/Graphic",
                "esri/symbols/SimpleMarkerSymbol",
                "esri/PopupTemplate",
                "esri/widgets/Popup",
                "esri/widgets/Search",
                "esri/widgets/Compass",
                "esri/widgets/Locate",
                "esri/widgets/BasemapToggle",
                "esri/widgets/Sketch",
                "esri/layers/GraphicsLayer",
                "esri/geometry/geometryEngine"
            ], function(Map, MapView, Point, Graphic, SimpleMarkerSymbol, PopupTemplate, Popup, Search, Compass, Locate, BasemapToggle, Sketch, GraphicsLayer, geometryEngine) {
                
                console.log('üó∫Ô∏è Initialisation ArcGIS dans Visualforce...');
                
                // Cr√©er la carte
                const map = new Map({
                    basemap: "streets-navigation-vector"
                });

                // Cr√©er un GraphicsLayer d√©di√© pour les dessins Sketch
                const sketchLayer = new GraphicsLayer({
                    title: "Dessins utilisateur"
                });
                map.add(sketchLayer);
                
                // Cr√©er la vue
                const view = new MapView({
                    container: "viewDiv",
                    map: map,
                    center: [-73.5673, 45.5017], // Place Ville-Marie, Montr√©al
                    zoom: 15,
                    constraints: {
                        rotationEnabled: true, // Activer la rotation pour le Compass
                        rotationAngle: 0 // Commencer avec l'orientation nord
                    }
                });

                // Cr√©er et configurer le widget Search avec autocompl√©tion (sans g√©olocalisation)
                const searchWidget = new Search({
                    view: view,
                    sources: [{
                        url: "https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer",
                        singleLineFieldName: "SingleLine",
                        name: "ArcGIS World Geocoding Service",
                        countryCode: "CAN", // Priorit√© au Canada
                        maxResults: 10,
                        maxSuggestions: 8,
                        minSuggestCharacters: 1,
                        searchExtent: view.extent
                    }],
                    autoComplete: true,
                    searchAllEnabled: false, // D√©sactiver la recherche globale pour √©viter la g√©olocalisation
                    includeDefaultSources: false, // Exclure les sources par d√©faut (incluant g√©olocalisation)
                    locationEnabled: false, // D√©sactiver explicitement la g√©olocalisation dans Search
                    popupEnabled: false, // On g√®re nos propres popups
                    resultGraphicEnabled: false, // On g√®re nos propres graphics
                    container: "searchContainer"
                });

                // Cr√©er et configurer le widget Compass (navigation)
                const compassWidget = new Compass({
                    view: view,
                    label: "R√©initialiser l'orientation nord"
                });

                // √âcouter les changements de rotation pour informer l'utilisateur
                view.watch("rotation", function(rotation) {
                    if (Math.abs(rotation) > 1) { // Si rotation significative
                        console.log('üß≠ Carte tourn√©e de', rotation.toFixed(1), 'degr√©s');
                        console.log('üí° Cliquez sur le compass pour remettre au nord');
                    }
                });

                // √âcouter les clics sur le compass
                compassWidget.on("click", function() {
                    console.log('üß≠ Compass cliqu√© - orientation remise au nord');
                });

                // Cr√©er et configurer le widget Locate (g√©olocalisation native ArcGIS)
                const locateWidget = new Locate({
                    view: view,
                    label: "Ma position",
                    useHeadingEnabled: true,
                    goToOverride: function(view, options) {
                        // Personnaliser le comportement de navigation vers la position
                        view.goTo({
                            target: options.target,
                            zoom: 18, // Zoom plus proche pour la position utilisateur
                            duration: 1000
                        });
                    }
                });

                // Cr√©er et configurer le widget BasemapToggle (changement de fond de carte)
                const basemapToggleWidget = new BasemapToggle({
                    view: view,
                    nextBasemap: "satellite", // Vue satellite comme alternative
                    label: "Basculer vers satellite"
                });

                // NOUVELLE APPROCHE: Cr√©er le widget Sketch SANS l'attacher √† la vue
                // Cela pr√©serve le comportement natif ArcGIS par d√©faut
                console.log('üéØ Mode NATIF ArcGIS activ√© - g√©ocodage sur clic disponible');
                
                // Variable globale pour le widget (cr√©√© mais pas attach√©)
                window.sketchWidget = null;
                window.sketchConfig = null;
                
                // Charger la configuration et cr√©er le widget Sketch automatiquement
                loadDrawingToolsConfig().then(config => {
                    console.log('üîß Configuration des outils charg√©e:', config);
                    
                    // Stocker la configuration pour utilisation ult√©rieure
                    window.sketchConfig = config;
                    console.log('üìã Configuration stock√©e - cr√©ation automatique du widget Sketch');
                    
                    // CR√âER AUTOMATIQUEMENT LE WIDGET SKETCH AVEC LA CONFIGURATION
                    createAndActivateSketchWidget();
                    
                }).catch(error => {
                    console.error('‚ùå Erreur lors du chargement de la configuration:', error);
                    
                    // Configuration par d√©faut en cas d'erreur
                    window.sketchConfig = {
                        pointTool: true,
                        polylineTool: true,
                        polygonTool: true,
                        rectangleTool: true,
                        circleTool: true,
                        lassoSelection: false,
                        rectangleSelection: false
                    };
                    console.log('üìã Configuration par d√©faut stock√©e');
                });

                // Fonction pour charger la configuration des outils depuis Custom Settings List
                function loadDrawingToolsConfig() {
                    return new Promise((resolve, reject) => {
                        try {
                            console.log('üîß Chargement de la configuration depuis Custom Settings List via Remote Objects...');
                            
                            // Utiliser Remote Objects pour r√©cup√©rer la configuration
                            const toolSettings = new SObjectModel.ArcGIS_Tool_Settings__c();
                            
                            toolSettings.retrieve({}, function(error, records) {
                                if (error) {
                                    console.error('‚ùå Erreur lors de la r√©cup√©ration des Custom Settings:', error);
                                    
                                    // Configuration par d√©faut en cas d'erreur
                                    const defaultConfig = {
                                        pointTool: false,
                                        polylineTool: false,
                                        polygonTool: false,
                                        rectangleTool: true,        // D√âFAUT: activ√©
                                        circleTool: true,           // D√âFAUT: activ√©
                                        lassoSelection: false,
                                        rectangleSelection: false
                                    };
                                    
                                    console.log('‚ö†Ô∏è Utilisation de la configuration par d√©faut:', defaultConfig);
                                    resolve(defaultConfig);
                                } else {
                                    console.log('‚úÖ Custom Settings r√©cup√©r√©s:', records);
                                    
                                    // Mapper les enregistrements vers la configuration
                                    const config = {
                                        pointTool: false,
                                        polylineTool: false,
                                        polygonTool: false,
                                        rectangleTool: false,
                                        circleTool: false,
                                        lassoSelection: false,
                                        rectangleSelection: false
                                    };
                                    
                                    records.forEach(record => {
                                        const toolType = record.get('Tool_Type__c');
                                        const isEnabled = record.get('Is_Enabled__c');
                                        
                                        console.log(`üîß Outil: ${record.get('Name')} (${toolType}) = ${isEnabled}`);
                                        
                                        switch(toolType) {
                                            case 'point':
                                                config.pointTool = isEnabled;
                                                break;
                                            case 'polyline':
                                                config.polylineTool = isEnabled;
                                                break;
                                            case 'polygon':
                                                config.polygonTool = isEnabled;
                                                break;
                                            case 'rectangle':
                                                config.rectangleTool = isEnabled;
                                                break;
                                            case 'circle':
                                                config.circleTool = isEnabled;
                                                break;
                                            case 'lasso-selection':
                                                config.lassoSelection = isEnabled;
                                                break;
                                            case 'rectangle-selection':
                                                config.rectangleSelection = isEnabled;
                                                break;
                                        }
                                    });
                                    
                                    console.log('üé® Configuration finale:', config);
                                    resolve(config);
                                }
                            });
                            
                        } catch (error) {
                            console.error('‚ùå Erreur lors du chargement de la configuration:', error);
                            
                            // Configuration par d√©faut en cas d'erreur
                            resolve({
                                pointTool: false,
                                polylineTool: false,
                                polygonTool: false,
                                rectangleTool: true,        // D√âFAUT: activ√©
                                circleTool: true,           // D√âFAUT: activ√©
                                lassoSelection: false,
                                rectangleSelection: false
                            });
                        }
                    });
                }
                

                
                // Fonction pour cr√©er et activer le widget Sketch √† la demande
                function createAndActivateSketchWidget() {
                    console.log('üé® Cr√©ation du widget Sketch avec configuration Custom Settings...');
                    
                    if (window.sketchWidget) {
                        console.log('‚ö†Ô∏è Widget Sketch d√©j√† cr√©√©');
                        return window.sketchWidget;
                    }
                    
                    if (!window.sketchConfig) {
                        console.error('‚ùå Configuration non disponible');
                        return null;
                    }
                    
                    console.log('üîß Configuration appliqu√©e au widget Sketch:', window.sketchConfig);
                    
                    // Cr√©er le widget avec la configuration stock√©e
                const sketchWidget = new Sketch({
                    view: view,
                    layer: sketchLayer,
                        creationMode: "hybrid",
                        defaultCreateOptions: { mode: "click" },
                        defaultUpdateOptions: { 
                            enableRotation: false,
                            enableScaling: false,
                            preserveAspectRatio: true
                        },
                    label: "Outils de dessin ArcGIS",
                    visibleElements: {
                        createTools: {
                                point: window.sketchConfig.pointTool,
                                polyline: window.sketchConfig.polylineTool,
                                polygon: window.sketchConfig.polygonTool,
                                rectangle: window.sketchConfig.rectangleTool,
                                circle: window.sketchConfig.circleTool
                        },
                        selectionTools: {
                                "lasso-selection": window.sketchConfig.lassoSelection,
                                "rectangle-selection": window.sketchConfig.rectangleSelection
                        },
                        undoRedoMenu: true,
                        settingsMenu: true
                    }
                });

                    // Stocker globalement
                    window.sketchWidget = sketchWidget;
                    
                    // AJOUTER LE WIDGET √Ä LA VUE (c'est ce qui manquait !)
                    view.ui.add(sketchWidget, "bottom-right");
                    console.log('üìç Widget Sketch ajout√© √† la vue en bas √† droite');
                    
                    // Initialiser le widget
                    initializeSketchWidget(sketchWidget);
                    
                    console.log('‚úÖ Widget Sketch cr√©√©, ajout√© √† la vue et activ√©');
                    return sketchWidget;
                }
                
                // Fonction pour d√©sactiver et d√©truire le widget Sketch
                function deactivateSketchWidget() {
                    console.log('üóëÔ∏è D√©sactivation du widget Sketch...');
                    
                    if (window.sketchWidget) {
                        // Annuler toute op√©ration en cours
                        window.sketchWidget.cancel();
                        
                        // D√©truire le widget
                        window.sketchWidget.destroy();
                        window.sketchWidget = null;
                        
                        console.log('‚úÖ Widget Sketch d√©sactiv√© - mode natif ArcGIS restaur√©');
                    }
                }
                
                // Fonction pour initialiser le widget Sketch (appel√©e apr√®s cr√©ation)
                function initializeSketchWidget(sketchWidget) {
                // Attendre que le widget soit initialis√©
                sketchWidget.when(() => {
                    console.log('‚úÖ Widget Sketch initialis√© avec succ√®s');
                        console.log('üé® Outils configur√©s selon Custom Settings');
                        
                        // √âTAT INITIAL: FORC√â EN MODE INACTIF POUR G√âOCODAGE
                        // Annuler tous les outils actifs et d√©sactiver le widget par d√©faut
                        sketchWidget.cancel(); // Annule tout outil de cr√©ation actif
                        sketchWidget.viewModel.state = "ready"; // Force l'√©tat ready
                        
                        console.log('üñ±Ô∏è Widget Sketch en mode READY - g√©ocodage disponible');
                        console.log('üîß √âtat du widget:', sketchWidget.viewModel.state);
                        
                        // Configurer les styles de highlight
                        setupHighlightStyles();
                    
                    // √âcouter la cr√©ation de formes
                    sketchWidget.on("create", function(event) {
                        console.log('üé® Forme cr√©√©e:', event);
                        if (event.state === "complete") {
                            handleShapeCreated(event.graphic);
                        }
                    });
                    
                    // √âcouter la s√©lection de formes
                    sketchWidget.on("select", function(event) {
                        console.log('üéØ Forme s√©lectionn√©e:', event);
                        handleShapeSelection();
                    });
                    
                    // √âcouter la d√©s√©lection de formes
                    sketchWidget.on("update", function(event) {
                        console.log('üîÑ Forme mise √† jour:', event);
                        if (event.state === "complete") {
                            handleShapeCreated(event.graphics[0]);
                        }
                    });
                    
                    // √âcouter la suppression de formes
                    sketchWidget.on("delete", function(event) {
                        console.log('üóëÔ∏è Forme supprim√©e:', event);
                        handleShapeDeletion();
                    });
                        
                        // IMPORTANT: Pr√©server le g√©ocodage sur clic de carte
                        // √âcouter les changements d'outil pour maintenir le g√©ocodage actif
                        sketchWidget.viewModel.watch("state", function(newState) {
                            console.log('üîß √âtat du widget Sketch chang√©:', newState);
                            
                            // Si aucun outil de cr√©ation n'est actif, le g√©ocodage reste disponible
                            if (newState === "ready" || newState === "disabled") {
                                console.log('üñ±Ô∏è Curseur de navigation/g√©ocodage disponible');
                                // La carte peut recevoir les clics pour le g√©ocodage
                            }
                    });
                });
                    
                    // Rendre le sketchWidget disponible globalement pour les autres fonctions
                    window.sketchWidget = sketchWidget;
                }
                
                // Fonction pour g√©rer la cr√©ation d'une forme
                function handleShapeCreated(graphic) {
                    console.log('üé® Nouvelle forme cr√©√©e:', graphic);
                    
                    // Notifier le LWC qu'une forme est disponible
                    if (window.parent) {
                        window.parent.postMessage({
                            type: 'SHAPE_SELECTED',
                            shape: extractShapeInfo(graphic)
                        }, '*');
                    }
                }
                
                // Fonction pour g√©rer la s√©lection de formes
                function handleShapeSelection() {
                    const selectedGraphics = sketchWidget.view.graphics.filter(g => g.selected);
                    console.log('üéØ Formes s√©lectionn√©es:', selectedGraphics.length);
                    
                    if (selectedGraphics.length > 0) {
                        // Notifier le LWC qu'une forme est s√©lectionn√©e
                        if (window.parent) {
                            window.parent.postMessage({
                                type: 'SHAPE_SELECTED',
                                shape: extractShapeInfo(selectedGraphics[0])
                            }, '*');
                        }
                    } else {
                        // Notifier le LWC qu'aucune forme n'est s√©lectionn√©e
                        if (window.parent) {
                            window.parent.postMessage({
                                type: 'NO_SHAPE_SELECTED'
                            }, '*');
                        }
                    }
                }
                
                // Fonction pour g√©rer la suppression de formes
                function handleShapeDeletion() {
                    const remainingGraphics = sketchWidget.view.graphics.length;
                    console.log('üóëÔ∏è Formes restantes:', remainingGraphics);
                    
                    if (remainingGraphics === 0) {
                        // Notifier le LWC qu'aucune forme n'est disponible
                        if (window.parent) {
                            window.parent.postMessage({
                                type: 'NO_SHAPE_SELECTED'
                            }, '*');
                        }
                    }
                }
                

                
                // Fonction pour extraire les informations d'une forme
                function extractShapeInfo(graphic) {
                    const geometry = graphic.geometry;
                    let shapeInfo = {
                        type: 'unknown',
                        coordinates: [],
                        center: null,
                        isCircle: false, // Flag pour pr√©server le type m√©tier Circle
                        address: null // Adresse obtenue par g√©ocodage
                    };
                    
                    // R√©cup√©rer l'adresse si disponible
                    if (graphic.attributes && graphic.attributes.address) {
                        const address = graphic.attributes.address;
                        // Ne pas inclure les messages d'erreur comme adresse
                        if (address && address !== "G√©ocodage en cours..." && 
                            address !== "Adresse non trouv√©e" && 
                            address !== "Erreur de g√©ocodage") {
                            shapeInfo.address = address;
                        }
                    }
                    
                    // Convertir la g√©om√©trie en WGS84 si n√©cessaire
                    const wgs84Geometry = convertToWGS84(geometry);
                    
                    if (wgs84Geometry.type === 'point') {
                        shapeInfo.type = 'Point';
                        shapeInfo.coordinates = [{
                            latitude: wgs84Geometry.latitude,
                            longitude: wgs84Geometry.longitude
                        }];
                        shapeInfo.center = {
                            latitude: wgs84Geometry.latitude,
                            longitude: wgs84Geometry.longitude
                        };
                    } else if (wgs84Geometry.type === 'polyline') {
                        shapeInfo.type = 'Line'; // Corriger pour correspondre aux valeurs picklist
                        shapeInfo.coordinates = wgs84Geometry.paths[0].map(coord => ({
                            latitude: coord[1],
                            longitude: coord[0]
                        }));
                        shapeInfo.center = wgs84Geometry.extent.center;
                    } else if (wgs84Geometry.type === 'polygon') {
                        // V√©rifier si c'est un cercle (cr√©√© avec l'outil circle)
                        const isCircle = isPolygonACircle(wgs84Geometry);
                        shapeInfo.type = isCircle ? 'Circle' : 'Polygon';
                        shapeInfo.isCircle = isCircle;
                        
                        shapeInfo.coordinates = wgs84Geometry.rings[0].map(coord => ({
                            latitude: coord[1],
                            longitude: coord[0]
                        }));
                        shapeInfo.center = wgs84Geometry.extent.center;
                    } else if (wgs84Geometry.type === 'extent') {
                        // Rectangle ou cercle
                        if (wgs84Geometry.width === wgs84Geometry.height) {
                            shapeInfo.type = 'Circle';
                            shapeInfo.isCircle = true;
                        } else {
                            shapeInfo.type = 'Rectangle';
                        }
                        shapeInfo.coordinates = [
                            { latitude: wgs84Geometry.ymin, longitude: wgs84Geometry.xmin },
                            { latitude: wgs84Geometry.ymax, longitude: wgs84Geometry.xmax }
                        ];
                        shapeInfo.center = wgs84Geometry.center;
                    }
                    
                    return shapeInfo;
                }
                
                // Fonction pour convertir une g√©om√©trie en WGS84
                function convertToWGS84(geometry) {
                    // V√©rifier si la g√©om√©trie est d√©j√† en WGS84
                    if (geometry.spatialReference && geometry.spatialReference.wkid === 4326) {
                        return geometry;
                    }
                    
                    // Si pas de spatialReference ou diff√©rent de 4326, convertir
                    try {
                        // Utiliser l'API ArcGIS pour la projection
                        if (geometry.spatialReference && geometry.spatialReference.wkid) {
                            console.log('üîÑ Conversion de la g√©om√©trie vers WGS84 depuis SR:', geometry.spatialReference.wkid);
                            
                            // Cr√©er un Point temporaire pour tester la projection
                            const testPoint = new Point({
                                x: geometry.type === 'point' ? geometry.x : geometry.extent ? geometry.extent.center.x : 0,
                                y: geometry.type === 'point' ? geometry.y : geometry.extent ? geometry.extent.center.y : 0,
                                spatialReference: geometry.spatialReference
                            });
                            
                            // Projeter vers WGS84
                            const projectedPoint = geometryEngine.project(testPoint, { wkid: 4326 });
                            
                            if (projectedPoint) {
                                console.log('‚úÖ Projection r√©ussie vers WGS84:', projectedPoint);
                                // La g√©om√©trie compl√®te sera projet√©e automatiquement par ArcGIS
                                return geometryEngine.project(geometry, { wkid: 4326 });
                            }
                        }
                        
                        // Fallback : utiliser la projection de la vue
                        if (view.spatialReference && view.spatialReference.wkid !== 4326) {
                            console.log('üîÑ Projection via la vue depuis SR:', view.spatialReference.wkid);
                            return geometryEngine.project(geometry, { wkid: 4326 });
                        }
                        
                        // Si on arrive ici, on consid√®re que c'est d√©j√† en WGS84
                        console.log('‚ÑπÔ∏è G√©om√©trie consid√©r√©e comme WGS84 par d√©faut');
                        return geometry;
                        
                    } catch (error) {
                        console.error('‚ùå Erreur lors de la projection vers WGS84:', error);
                        // En cas d'erreur, retourner la g√©om√©trie originale
                        return geometry;
                    }
                }
                
                // Fonction pour d√©tecter si un polygone est un cercle
                function isPolygonACircle(geometry) {
                    if (geometry.type !== 'polygon' || !geometry.rings || geometry.rings.length === 0) {
                        return false;
                    }
                    
                    const ring = geometry.rings[0];
                    if (ring.length < 4) return false;
                    
                    // V√©rifier si c'est approximativement circulaire
                    // Un cercle a des angles r√©guliers et une forme relativement sym√©trique
                    const center = geometry.extent.center;
                    const distances = ring.map(coord => {
                        const dx = coord[0] - center.longitude;
                        const dy = coord[1] - center.latitude;
                        return Math.sqrt(dx * dx + dy * dy);
                    });
                    
                    // Calculer la variance des distances (plus elle est faible, plus c'est circulaire)
                    const avgDistance = distances.reduce((sum, d) => sum + d, 0) / distances.length;
                    const variance = distances.reduce((sum, d) => sum + Math.pow(d - avgDistance, 2), 0) / distances.length;
                    const coefficientOfVariation = Math.sqrt(variance) / avgDistance;
                    
                    // Si le coefficient de variation est faible, c'est probablement un cercle
                    return coefficientOfVariation < 0.1; // Seuil ajustable
                }
                
                // Fonction pour s'assurer que les coordonn√©es sont en WGS84
                function ensureWGS84Coordinates(shapeInfo) {
                    // V√©rifier si les coordonn√©es sont dans les bornes WGS84
                    const isValidWGS84 = (lat, lon) => lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180;
                    
                    // V√©rifier le centre
                    if (shapeInfo.center && !isValidWGS84(shapeInfo.center.latitude, shapeInfo.center.longitude)) {
                        console.warn('‚ö†Ô∏è Coordonn√©es du centre hors bornes WGS84:', shapeInfo.center);
                    }
                    
                    // V√©rifier toutes les coordonn√©es
                    if (shapeInfo.coordinates) {
                        shapeInfo.coordinates.forEach((coord, index) => {
                            if (!isValidWGS84(coord.latitude, coord.longitude)) {
                                console.warn(`‚ö†Ô∏è Coordonn√©e ${index} hors bornes WGS84:`, coord);
                            }
                        });
                    }
                    
                    return shapeInfo;
                }

                // Gestion simple des erreurs de g√©olocalisation
                locateWidget.on("locate-error", function(event) {
                    console.warn('‚ö†Ô∏è Erreur de g√©olocalisation:', event.error);
                    
                    if (event.error.code === 1) {
                        // Permission refus√©e
                        console.warn('‚ùå Permission de g√©olocalisation refus√©e par l\'utilisateur');
                    } else if (event.error.code === 2) {
                        // Position indisponible
                        console.warn('‚ùå Position indisponible');
                    } else if (event.error.code === 3) {
                        // Timeout
                        console.warn('‚è∞ Timeout de g√©olocalisation');
                    }
                });

                // G√©rer le succ√®s de g√©olocalisation
                locateWidget.on("locate", function(event) {
                    console.log('‚úÖ G√©olocalisation r√©ussie:', event);
                });

                // Ajouter le widget Locate √† la vue
                view.ui.add(locateWidget, "bottom-left");

                // Ajouter les widgets √† la vue selon les conventions ArcGIS
                view.ui.add(searchWidget, "top-left");      // Recherche (d√©j√† impl√©ment√©)
                view.ui.add(compassWidget, "top-right");   // Compass (navigation)
                view.ui.add(basemapToggleWidget, "top-right"); // BasemapToggle (changement de fond)
                view.ui.add(locateWidget, "bottom-left");  // Locate (g√©olocalisation)
                view.ui.add(sketchWidget, "bottom-right"); // Sketch (outils de dessin)
                // Zoom reste en "bottom-right" par d√©faut (coexiste avec Sketch)

                console.log('üéØ Widgets ajout√©s selon conventions ArcGIS:');
                console.log('  - Search: top-left (recherche)');
                console.log('  - Compass: top-right (navigation)');
                console.log('  - BasemapToggle: top-right (changement de fond)');
                console.log('  - Locate: bottom-left (g√©olocalisation)');
                console.log('  - Sketch: bottom-right (outils de dessin)');
                console.log('  - Zoom: bottom-right (par d√©faut, coexiste avec Sketch)');
                console.log('');
                console.log('üß≠ ROTATION ACTIV√âE:');
                console.log('  - PC: Shift + glisser pour tourner la carte');
                console.log('  - Mobile: Rotation avec deux doigts');
                console.log('  - Compass: Clic pour remettre au nord');

                // √âcouter la s√©lection d'une suggestion de recherche
                searchWidget.on("select-result", function(event) {
                    console.log('üîç Suggestion s√©lectionn√©e:', event);
                    
                    if (event.result) {
                        const result = event.result;
                        const location = result.extent || result.feature.geometry;
                        
                        if (location) {
                            // Centrer la carte sur le r√©sultat
                            if (location.extent) {
                                view.goTo(location.extent, { duration: 1000 });
                            } else {
                                view.goTo(location, { duration: 1000 });
                            }
                            
                            // Cr√©er un marqueur sur l'emplacement trouv√©
                            const point = location.extent ? location.extent.center : location;
                            const symbol = new SimpleMarkerSymbol({
                                color: [0, 122, 194], // Bleu ArcGIS
                                outline: {
                                    color: [255, 255, 255],
                                    width: 2
                                },
                                size: 12
                            });
                            
                            const graphic = new Graphic({
                                geometry: point,
                                symbol: symbol,
                                attributes: {
                                    latitude: point.latitude ? point.latitude.toFixed(6) : "N/A",
                                    longitude: point.longitude ? point.longitude.toFixed(6) : "N/A",
                                    address: result.name || "Adresse trouv√©e"
                                },
                                popupTemplate: popupTemplate
                            });
                            
                            // Nettoyer les anciens marqueurs et ajouter le nouveau
                            view.graphics.removeAll();
                            view.graphics.add(graphic);
                            
                            // Ouvrir imm√©diatement le popup avec "G√©ocodage en cours..."
                            view.openPopup({
                                title: "üìç Adresse",
                                content: `
                                    <div style="padding: 15px; text-align: center;">
                                        <div style="margin-bottom: 15px;">
                                            <img src="https://js.arcgis.com/4.33/esri/themes/base/images/Loading_Indicator.gif" alt="Loading..." width="20" height="20" />
                                        </div>
                                        <p style="font-size: 14px; color: #666; margin: 0;">
                                            G√©ocodage en cours...
                                        </p>
                                    </div>
                                `,
                                location: point
                            });
                            
                            // Faire le g√©ocodage en arri√®re-plan comme pour les clics manuels
                            performGeocoding(point.latitude, point.longitude, graphic);
                            
                            console.log('‚úÖ Carte centr√©e sur:', result.name, 'g√©ocodage en cours...');
                        }
                    }
                });
                
                // Cr√©er le PopupTemplate pour afficher les informations de g√©ocodage
                const popupTemplate = new PopupTemplate({
                    title: "üìç Informations de localisation",
                    content: [
                        {
                            type: "fields",
                            fieldInfos: [
                                {
                                    fieldName: "address",
                                    label: "Adresse",
                                    visible: true
                                },
                                {
                                    fieldName: "latitude",
                                    label: "Latitude",
                                    visible: true
                                },
                                {
                                    fieldName: "longitude",
                                    label: "Longitude",
                                    visible: true
                                }
                            ]
                        }
                    ]
                });
                
                // Configuration des clics sur graphics int√©gr√©e dans le handler principal
                
                view.when(() => {
                    console.log('‚úÖ Carte ArcGIS VF initialis√©e !');
                    
                    // Notifier le parent (LWC) que la carte est pr√™te
                    if (window.parent) {
                        window.parent.postMessage({
                            type: 'MAP_READY',
                            message: 'ArcGIS map initialized successfully'
                        }, '*');
                    }
                });
                
                // HANDLER DE CLIC NATIF ARCGIS - G√âOCODAGE TOUJOURS ACTIF
                // En mode natif (sans widget Sketch), ce handler fonctionne toujours
                view.on("click", function(event) {
                    console.log('üñ±Ô∏è Clic d√©tect√© sur la carte - mode natif ArcGIS');
                    
                    // Si le widget Sketch existe et est actif, ne pas interf√©rer
                    if (window.sketchWidget && window.sketchWidget.viewModel.state !== "ready" && window.sketchWidget.viewModel.state !== "disabled") {
                        console.log('üé® Widget Sketch actif - g√©ocodage suspendu');
                        return; // Laisser le widget Sketch g√©rer le clic
                    }
                    
                    console.log('‚úÖ Mode navigation natif - g√©ocodage sur clic activ√©');
                    
                    const coords = {
                        longitude: event.mapPoint.longitude,
                        latitude: event.mapPoint.latitude
                    };
                    
                    console.log('üìç Coordonn√©es:', coords);
                    
                    // Envoyer les coordonn√©es au parent (LWC)
                    if (window.parent) {
                        window.parent.postMessage({
                            type: 'MAP_CLICK',
                            coordinates: coords
                        }, '*');
                        console.log('üì® Message envoy√© au parent LWC');
                    }
                    
                    // Cr√©er un point pour le popup
                    const point = new Point({
                        longitude: event.mapPoint.longitude,
                        latitude: event.mapPoint.latitude
                    });
                    
                    // Cr√©er un marqueur temporaire
                    const symbol = new SimpleMarkerSymbol({
                        color: [226, 119, 40],
                        outline: {
                            color: [255, 255, 255],
                            width: 2
                        }
                    });
                    
                    // Cr√©er le graphic avec le popup
                    const graphic = new Graphic({
                        geometry: point,
                        symbol: symbol,
                        popupTemplate: popupTemplate,
                        attributes: {
                            latitude: coords.latitude.toFixed(6),
                            longitude: coords.longitude.toFixed(6),
                            address: "G√©ocodage en cours..."
                        }
                    });
                    
                    // Nettoyer les anciens marqueurs et ajouter le nouveau
                    view.graphics.removeAll();
                    view.graphics.add(graphic);
                    
                    // Ouvrir imm√©diatement le popup avec "G√©ocodage en cours..."
                    view.openPopup({
                        title: "üìç Adresse",
                        content: `
                            <div style="padding: 15px; text-align: center;">
                                <div style="margin-bottom: 15px;">
                                    <img src="https://js.arcgis.com/4.33/esri/themes/base/images/Loading_Indicator.gif" alt="Loading..." width="20" height="20" />
                                </div>
                                <p style="font-size: 14px; color: #666; margin: 0;">
                                    G√©ocodage en cours...
                                </p>
                            </div>
                        `,
                        location: point
                    });
                    
                    // Faire le g√©ocodage en arri√®re-plan
                    performGeocoding(coords.latitude, coords.longitude, graphic);
                    
                    console.log('‚úÖ G√©ocodage d√©marr√© - popup ouvert');
                }, { passive: false }); // √âv√©nement non-passif pour permettre preventDefault si n√©cessaire
                
                // Fonction de g√©ocodage
                function performGeocoding(latitude, longitude, graphic) {
                    console.log('üåç D√©but g√©ocodage pour:', latitude, longitude);
                    
                    // Appel √† l'API ArcGIS Geocoding
                    const geocodeUrl = `https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/reverseGeocode?location=${longitude},${latitude}&outSR=4326&returnIntersection=false&f=json`;
                    
                    fetch(geocodeUrl)
                        .then(response => response.json())
                        .then(data => {
                            console.log('‚úÖ R√©ponse g√©ocodage:', data);
                            
                            if (data.address) {
                                const address = formatAddress(data.address);
                                console.log('üè† Adresse format√©e:', address);
                                
                                // Mettre √† jour le graphic avec l'adresse
                                graphic.attributes.address = address;
                                
                                console.log('‚úÖ Adresse mise √† jour dans le graphic');
                                
                                // Ouvrir automatiquement le popup avec l'adresse
                                view.openPopup({
                                    title: "üìç Adresse",
                                    content: `
                                        <div style="padding: 20px; text-align: center;">
                                            <div style="font-size: 16px; line-height: 1.4; color: #333;">
                                                ${address}
                                            </div>
                                        </div>
                                    `,
                                    location: graphic.geometry
                                });
                                
                                console.log('üéØ Popup ouvert automatiquement avec l\'adresse');
                                
                                // NOTIFIER LE LWC QU'UNE ADRESSE EST S√âLECTIONN√âE (comme une forme dessin√©e)
                                if (window.parent) {
                                    window.parent.postMessage({
                                        type: 'ADDRESS_SELECTED',
                                        address: {
                                            type: 'Adresse',
                                            coordinates: [{
                                                latitude: parseFloat(graphic.attributes.latitude),
                                                longitude: parseFloat(graphic.attributes.longitude)
                                            }],
                                            center: {
                                                latitude: parseFloat(graphic.attributes.latitude),
                                                longitude: parseFloat(graphic.attributes.longitude)
                                            },
                                            address: address,
                                            isAddress: true // Flag pour identifier les adresses
                                        }
                                    }, '*');
                                    
                                    console.log('üì® Message ADDRESS_SELECTED envoy√© au parent LWC avec adresse:', address);
                                }
                            } else {
                                console.log('‚ö†Ô∏è Aucune adresse trouv√©e');
                                graphic.attributes.address = "Adresse non trouv√©e";
                                
                                // NOTIFIER LE LWC QU'UNE ADRESSE EST S√âLECTIONN√âE (m√™me sans adresse)
                                if (window.parent) {
                                    window.parent.postMessage({
                                        type: 'ADDRESS_SELECTED',
                                        address: {
                                            type: 'Adresse',
                                            coordinates: [{
                                                latitude: parseFloat(graphic.attributes.latitude),
                                                longitude: parseFloat(graphic.attributes.longitude)
                                            }],
                                            center: {
                                                latitude: parseFloat(graphic.attributes.latitude),
                                                longitude: parseFloat(graphic.attributes.longitude)
                                            },
                                            address: "Adresse non trouv√©e",
                                            isAddress: true // Flag pour identifier les adresses
                                        }
                                    }, '*');
                                    
                                    console.log('üì® Message ADDRESS_SELECTED envoy√© au parent LWC (sans adresse)');
                                }
                                
                                // Ouvrir popup avec message d'erreur
                                view.openPopup({
                                    title: "üìç Adresse",
                                    content: `
                                        <div style="padding: 20px; text-align: center;">
                                            <div style="font-size: 16px; color: #d73a49; margin-bottom: 10px;">
                                                ‚ö†Ô∏è Adresse non trouv√©e
                                            </div>
                                            <div style="font-size: 14px; color: #666;">
                                                Impossible de r√©cup√©rer l'adresse pour ces coordonn√©es
                                            </div>
                                        </div>
                                    `,
                                    location: graphic.geometry
                                });
                            }
                        })
                        .catch(error => {
                            console.error('‚ùå Erreur g√©ocodage:', error);
                            graphic.attributes.address = "Erreur de g√©ocodage";
                            
                            // Ouvrir popup avec message d'erreur
                            view.openPopup({
                                title: "üìç Adresse",
                                content: `
                                    <div style="padding: 20px; text-align: center;">
                                        <div style="font-size: 16px; color: #d73a49; margin-bottom: 10px;">
                                            ‚ùå Erreur de g√©ocodage
                                        </div>
                                        <div style="font-size: 14px; color: #666;">
                                            Impossible de r√©cup√©rer l'adresse
                                        </div>
                                    </div>
                                `,
                                location: graphic.geometry
                            });
                        });
                }
                
                // Fonction de formatage d'adresse
                function formatAddress(addressData) {
                    const parts = [];
                    
                    if (addressData.Address) parts.push(addressData.Address);
                    if (addressData.City) parts.push(addressData.City);
                    if (addressData.Region) parts.push(addressData.Region);
                    if (addressData.Postal) parts.push(addressData.Postal);
                    if (addressData.CountryCode) parts.push(addressData.CountryCode);
                    
                    return parts.length > 0 ? parts.join(', ') : 'Adresse non disponible';
                }
                
                // √âcouter les messages du parent (LWC)
                window.addEventListener('message', function(event) {
                    console.log('üì® Message re√ßu du LWC:', event.data);
                    
                    if (event.data.type === 'CENTER_MAP') {
                        view.center = [event.data.longitude, event.data.latitude];
                        if (event.data.zoom) {
                            view.zoom = event.data.zoom;
                        }
                    } else if (event.data.type === 'GEOCODE_REQUEST') {
                        console.log('üåç Demande de g√©ocodage re√ßue:', event.data.coordinates);
                        
                        // Cr√©er un point pour le popup
                        const point = new Point({
                            longitude: event.data.coordinates.longitude,
                            latitude: event.data.coordinates.latitude
                        });
                        
                        // Cr√©er le graphic avec le popup
                        const graphic = new Graphic({
                            geometry: point,
                            symbol: new SimpleMarkerSymbol({
                                color: [226, 119, 40],
                                outline: { color: [255, 255, 255], width: 2 }
                            }),
                            popupTemplate: popupTemplate,
                            attributes: {
                                latitude: event.data.coordinates.latitude.toFixed(6),
                                longitude: event.data.coordinates.longitude.toFixed(6),
                                address: "G√©ocodage en cours..."
                            }
                        });
                        
                        // Nettoyer et ajouter le nouveau marqueur
                        view.graphics.removeAll();
                        view.graphics.add(graphic);
                        
                        // Ouvrir imm√©diatement le popup avec "G√©ocodage en cours..."
                        view.openPopup({
                            title: "üìç Adresse",
                            content: `
                                <div style="padding: 15px; text-align: center;">
                                    <div style="margin-bottom: 15px;">
                                        <img src="https://js.arcgis.com/4.33/esri/themes/base/images/Loading_Indicator.gif" alt="Loading..." width="20" height="20" />
                                    </div>
                                    <p style="font-size: 20px; color: #666; margin: 0;">
                                        G√©ocodage en cours...
                                    </p>
                                </div>
                            `,
                            location: point
                        });
                        
                        // Faire le g√©ocodage
                        performGeocoding(event.data.coordinates.latitude, event.data.coordinates.longitude, graphic);
                        
                        console.log('‚úÖ Popup ouvert depuis LWC, g√©ocodage en cours');
                    } else if (event.data.type === 'GET_CURRENT_SHAPE') {
                        console.log('üéØ Demande de forme actuelle re√ßue');
                        
                        // R√©cup√©rer toutes les formes du sketchLayer
                        const allGraphics = sketchLayer.graphics.toArray();
                        console.log('üé® Formes disponibles:', allGraphics.length);
                        
                        if (allGraphics.length > 0) {
                            // Extraire les informations de toutes les formes
                            const shapes = allGraphics.map(graphic => extractShapeInfo(graphic));
                            
                            // Envoyer la r√©ponse au LWC
                            if (window.parent) {
                                window.parent.postMessage({
                                    type: 'CURRENT_SHAPES_RESPONSE',
                                    shapes: shapes,
                                    totalCount: shapes.length
                                }, '*');
                            }
                            
                            console.log('üì® R√©ponse envoy√©e au LWC:', shapes);
                        } else {
                            // Aucune forme disponible
                            if (window.parent) {
                                window.parent.postMessage({
                                    type: 'CURRENT_SHAPES_RESPONSE',
                                    shapes: [],
                                    totalCount: 0
                                }, '*');
                            }
                            
                            console.log('üì® R√©ponse envoy√©e au LWC: Aucune forme');
                        }
                    } else if (event.data.type === 'CLEAR_SELECTION') {
                        console.log('üóëÔ∏è Demande de d√©s√©lection re√ßue');
                        
                        // D√©s√©lectionner toutes les formes
                        if (sketchWidget && sketchWidget.view) {
                            sketchWidget.view.graphics.forEach(graphic => {
                                graphic.selected = false;
                            });
                        }
                        
                        // Notifier le LWC que la s√©lection est vide
                        if (window.parent) {
                            window.parent.postMessage({
                                type: 'NO_SHAPE_SELECTED'
                            }, '*');
                        }
                        
                        console.log('‚úÖ S√©lection de la carte vid√©e');
                    } else if (event.data.type === 'ACTIVATE_DRAWING_MODE') {
                        console.log('üé® Activation du mode dessin demand√©e');
                        
                        // Cr√©er et activer le widget Sketch
                        createAndActivateSketchWidget();
                        
                    } else if (event.data.type === 'DEACTIVATE_DRAWING_MODE') {
                        console.log('üñ±Ô∏è D√©sactivation du mode dessin - retour natif ArcGIS');
                        
                        // D√©sactiver le widget Sketch et revenir au mode natif
                        deactivateSketchWidget();
                        
                    } else if (event.data.type === 'SET_DRAWING_MODE') {
                        console.log('üîß Changement de mode de dessin:', event.data.tool);
                        
                        // S'assurer que le widget existe
                        if (!window.sketchWidget) {
                            createAndActivateSketchWidget();
                        }
                        
                        // Activer l'outil sp√©cifique
                        if (window.sketchWidget) {
                            setDrawingMode(event.data.tool);
                        }
                        
                    } else if (event.data.type === 'UNDO_LAST_SHAPE') {
                        console.log('‚Ü∂ Annulation de la derni√®re forme');
                        undoLastShape();
                    }
                });
                
                // Fonction pour changer le mode de dessin
                function setDrawingMode(tool) {
                    if (!window.sketchWidget) {
                        console.warn('‚ö†Ô∏è SketchWidget pas encore initialis√©');
                        return;
                    }
                    
                    try {
                        // D√©sactiver d'abord tous les outils
                        window.sketchWidget.cancel();
                        
                        if (tool === 'select') {
                            // Mode s√©lection - pas d'outil actif
                            console.log('‚úã Mode s√©lection activ√©');
                        } else {
                            // Activer l'outil demand√©
                            const toolMapping = {
                                'point': 'point',
                                'polyline': 'polyline', 
                                'polygon': 'polygon',
                                'rectangle': 'rectangle',
                                'circle': 'circle'
                            };
                            
                            const sketchTool = toolMapping[tool];
                            if (sketchTool) {
                                // V√âRIFIER QUE L'OUTIL EST AUTORIS√â DANS LA CONFIGURATION
                                if (window.sketchConfig && window.sketchConfig[sketchTool + 'Tool']) {
                                    window.sketchWidget.create(sketchTool);
                                    console.log('üé® Outil activ√©:', sketchTool);
                                } else {
                                    console.warn('‚ö†Ô∏è Outil non autoris√© dans la configuration:', sketchTool);
                                    // Revenir au mode s√©lection
                                    window.sketchWidget.cancel();
                                }
                            } else {
                                console.warn('‚ö†Ô∏è Outil non reconnu:', tool);
                            }
                        }
                        
                        // Mettre √† jour le compteur
                        updateShapeCount();
                        
                    } catch (error) {
                        console.error('‚ùå Erreur lors du changement d\'outil:', error);
                    }
                }
                
                // Fonction pour mettre √† jour dynamiquement la configuration des outils
                function updateDrawingToolsConfig() {
                    console.log('üîÑ Mise √† jour dynamique de la configuration des outils...');
                    
                    // Recharger la configuration depuis Custom Settings
                    loadDrawingToolsConfig().then(newConfig => {
                        console.log('‚úÖ Nouvelle configuration charg√©e:', newConfig);
                        
                        // Mettre √† jour la configuration globale
                        window.sketchConfig = newConfig;
                        
                        // Mettre √† jour le widget Sketch si il existe
                        if (window.sketchWidget) {
                            console.log('üîß Mise √† jour du widget Sketch avec la nouvelle configuration');
                            
                            // Recr√©er le widget avec la nouvelle configuration
                            deactivateSketchWidget();
                            createAndActivateSketchWidget();
                        }
                        
                    }).catch(error => {
                        console.error('‚ùå Erreur lors de la mise √† jour de la configuration:', error);
                    });
                }
                
                // Fonction pour annuler la derni√®re forme
                function undoLastShape() {
                    if (!sketchLayer) {
                        console.warn('‚ö†Ô∏è SketchLayer pas encore initialis√©');
                        return;
                    }
                    
                    try {
                        const graphics = sketchLayer.graphics;
                        if (graphics.length > 0) {
                            // Supprimer la derni√®re forme ajout√©e
                            const lastGraphic = graphics.getItemAt(graphics.length - 1);
                            sketchLayer.remove(lastGraphic);
                            console.log('üóëÔ∏è Derni√®re forme supprim√©e');
                            
                            // Mettre √† jour le compteur
                            updateShapeCount();
                        } else {
                            console.log('‚ÑπÔ∏è Aucune forme √† annuler');
                        }
                    } catch (error) {
                        console.error('‚ùå Erreur lors de l\'annulation:', error);
                    }
                }
                
                // Fonction pour mettre √† jour le compteur de formes
                function updateShapeCount() {
                    if (!sketchLayer) return;
                    
                    const totalCount = sketchLayer.graphics.length;
                    const selectedCount = sketchLayer.graphics.filter(g => g.selected).length;
                    
                    // Envoyer la mise √† jour au LWC
                    if (window.parent) {
                        window.parent.postMessage({
                            type: 'SHAPE_COUNT_UPDATE',
                            totalCount: totalCount,
                            selectedCount: selectedCount
                        }, '*');
                    }
                    
                    console.log(`üìä Compteur mis √† jour: ${totalCount} formes, ${selectedCount} s√©lectionn√©es`);
                }
                
                // Fonction pour configurer les styles de highlight
                function setupHighlightStyles() {
                    // Configurer les styles des formes s√©lectionn√©es
                    if (sketchWidget && sketchWidget.viewModel) {
                        // Style pour les formes s√©lectionn√©es
                        const selectedStyle = {
                            color: [255, 165, 0, 0.8], // Orange avec transparence
                            outline: {
                                color: [255, 100, 0, 1], // Orange fonc√© pour le contour
                                width: 3
                            }
                        };
                        
                        // Style pour les formes non s√©lectionn√©es
                        const normalStyle = {
                            color: [0, 122, 194, 0.6], // Bleu ArcGIS avec transparence
                            outline: {
                                color: [0, 122, 194, 1], // Bleu ArcGIS pour le contour
                                width: 2
                            }
                        };
                        
                        console.log('üé® Styles de highlight configur√©s');
                        
                        // √âcouter les changements de s√©lection pour appliquer les styles
                        sketchWidget.on("select", function(event) {
                            applyHighlightStyles();
                        });
                        
                        sketchWidget.on("update", function(event) {
                            if (event.state === "complete") {
                                applyHighlightStyles();
                            }
                        });
                    }
                }
                
                // Fonction pour appliquer les styles de highlight
                function applyHighlightStyles() {
                    if (!sketchLayer) return;
                    
                    sketchLayer.graphics.forEach(graphic => {
                        if (graphic.selected) {
                            // Style pour les formes s√©lectionn√©es (orange)
                            if (graphic.geometry.type === 'point') {
                                graphic.symbol = {
                                    type: "simple-marker",
                                    color: [255, 165, 0, 0.8],
                                    outline: {
                                        color: [255, 100, 0, 1],
                                        width: 3
                                    },
                                    size: 12
                                };
                            } else {
                                graphic.symbol = {
                                    type: graphic.geometry.type === 'polyline' ? "simple-line" : "simple-fill",
                                    color: [255, 165, 0, 0.3],
                                    outline: {
                                        color: [255, 100, 0, 1],
                                        width: 3
                                    }
                                };
                            }
                        } else {
                            // Style pour les formes normales (bleu)
                            if (graphic.geometry.type === 'point') {
                                graphic.symbol = {
                                    type: "simple-marker",
                                    color: [0, 122, 194, 0.8],
                                    outline: {
                                        color: [0, 122, 194, 1],
                                        width: 2
                                    },
                                    size: 10
                                };
                            } else {
                                graphic.symbol = {
                                    type: graphic.geometry.type === 'polyline' ? "simple-line" : "simple-fill",
                                    color: [0, 122, 194, 0.2],
                                    outline: {
                                        color: [0, 122, 194, 1],
                                        width: 2
                                    }
                                };
                            }
                        }
                    });
                    
                    console.log('üé® Styles de highlight appliqu√©s');
                }
            });
        </script>
    </body>
    </html>
</apex:page>
